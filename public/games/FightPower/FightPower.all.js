/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\n * Created by guolei on 16/3/14.\n */\nvar renderManager = __webpack_require__(1);\nvar configManager = __webpack_require__(3);\n//const GameScene = require(\"./layers/game-scene\");\nvar DemoLayer = __webpack_require__(4);\nvar Resources = __webpack_require__(57).g_res;\nvar petData = __webpack_require__(58);\nvar Scale = __webpack_require__(62);\n(function () {\n    renderManager.init();\n    configManager.init(function () {\n        petData.init();\n    });\n\n    ////\n    //window.addEventListener('resize',function(event){\n    //    let scale =  Scale(renderManager.renderer.view);\n    //    //renderManager.renderer.view.scale.x = scale;\n    //    //renderManager.renderer.view.scale.y = scale;\n    //});\n    if (PIXI.loader) {\n        PIXI.loader.add(Resources).load(function () {\n            var game = DemoLayer();\n            game.init();\n        });\n    }\n})();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/main.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/main.js?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\n/**\n * Created by guolei on 16/3/14.\n */\nvar Conf = __webpack_require__(2);\n\nvar RendererManager = function RendererManager() {\n    var that = {};\n    that.renderer = null;\n\n    that.init = function () {\n        that.renderer = PIXI.autoDetectRenderer(Conf.Canvas.width, Conf.Canvas.height);\n        document.body.appendChild(that.renderer.view);\n    };\n\n    return that;\n};\nmodule.exports = RendererManager();\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/tools/renderer-manager.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/tools/renderer-manager.js?");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("'use strict';\n\n/**\n * Created by guolei on 16/3/14.\n */\nvar Conf = Conf || {};\nvar Width = 480,\n    Height = 754;\nConf.Canvas = {\n    width: Width,\n    height: Height,\n    posX_center: Width * 0.5,\n    posY_center: Height * 0.5\n\n};\nConf.ConfigType = {\n    PetActions: './assets/json/pet_actions-config.json',\n    PetLevels: './assets/json/pet_levels-config.json'\n};\n\nmodule.exports = Conf;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/tools/conf.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/tools/conf.js?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\n * Created by guolei on 16/3/22.\n */\nvar configType = __webpack_require__(2).ConfigType;\nvar ConfigManager = function () {\n    var that = {};\n    var configMaps = {};\n\n    that.init = function (callFunc) {\n        readConfig(callFunc);\n    };\n\n    that.getConfigByType = function (type) {\n        return configMaps[type];\n    };\n\n    function readConfig(callFunc) {\n        var _loop = function _loop(i) {\n            EZGUI.utils.loadJSON(configType[i], function (themeConfig) {\n                configMaps[configType[i]] = themeConfig;\n                callFunc();\n            });\n        };\n\n        for (var i in configType) {\n            _loop(i);\n        }\n    }\n\n    return that;\n}();\nmodule.exports = ConfigManager;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/tools/config-manager.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/tools/config-manager.js?");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\n/**\n * Created by guolei on 16/3/16.\n */\nvar BaseLayer = __webpack_require__(5);\nvar Inherited = __webpack_require__(55);\nvar DemoLayout = __webpack_require__(56);\nvar Conf = __webpack_require__(2);\nvar Resource = __webpack_require__(57).res;\nvar Utils = __webpack_require__(6);\nvar Data = __webpack_require__(58);\nvar Tools = __webpack_require__(59);\nvar configManager = __webpack_require__(3);\nvar TimerButton = __webpack_require__(61);\nvar RendererManager = __webpack_require__(1);\n\nfunction DemoLayer() {\n    var LayerJson = \"./assets/themes/demo-theme.json\";\n    var that = Inherited(BaseLayer());\n    var _petAnimation = null;\n    var _layerGui = null;\n    var _actionData = null;\n\n    var _feedTimerButton = null;\n    var _batheTimerButton = null;\n    var _shopTimerButton = null;\n    var _exerciseTimerButton = null;\n\n    var _gameBgLayer = null;\n\n    var _tweenLeft = null;\n    var _tweenBgPos = null;\n    var _tweenRight = null;\n    var _tweenMid = null;\n\n    var _tweenPetPos = null;\n    var _tweenPetFront = null;\n    var _tweenPetBack = null;\n    var _tweenPetMid = null;\n\n    that.inheritOn(\"init\", function () {\n\n        _gameBgLayer = PIXI.Sprite.fromImage(Resource.game_bg);\n        _gameBgLayer.position.x = -192;\n        _gameBgLayer.position.y = 100;\n        that.node.addChild(_gameBgLayer);\n        moveActions();\n\n        _actionData = configManager.getConfigByType(Conf.ConfigType.PetActions);\n\n        var layer = EZGUI.Theme.load([LayerJson], function () {\n            _layerGui = EZGUI.create(DemoLayout, \"demo\");\n            _feedTimerButton = TimerButton(EZGUI.components.feed, _actionData.feed.time);\n            _batheTimerButton = TimerButton(EZGUI.components.bathe, _actionData.bathe.time);\n            _shopTimerButton = TimerButton(EZGUI.components.shopping, _actionData.shopping.time);\n            _exerciseTimerButton = TimerButton(EZGUI.components.exercise, _actionData.exercise.time);\n\n            _feedTimerButton.click(ClickedOn);\n            _batheTimerButton.click(ClickedOn);\n            _shopTimerButton.click(ClickedOn);\n            _exerciseTimerButton.click(ClickedOn);\n\n            that.node.addChild(_layerGui);\n\n            //Utils.scaleToWindow(RendererManager.renderer,that.node);\n            initAnimation();\n            refreshLayerInfo();\n            petActions();\n        });\n    });\n\n    function refreshLayerInfo() {\n        initLayerInfo();\n    }\n\n    function initLayerInfo() {\n        EZGUI.components.attack_num.text = Data.getPetData().attack;\n        EZGUI.components.life_num.text = Data.getPetData().life;\n    };\n\n    function initAnimation() {\n        _petAnimation = Utils.createSpine(Resource.catSpine);\n        _petAnimation.interactive = true;\n        _petAnimation.buttonMode = true;\n        _petAnimation.position.x = Conf.Canvas.posX_center;\n        _petAnimation.position.y = Conf.Canvas.posY_center + 100;\n        _petAnimation.scale.set(0.5);\n        _petAnimation.state.setAnimationByName(0, 'stand', true);\n        //stage.addChild(_petAnimation);\n        _petAnimation\n        // events for drag start\n        .on('mousedown', onDragStart).on('touchstart', onDragStart)\n        // events for drag end\n        .on('mouseup', onDragEnd).on('mouseupoutside', onDragEnd).on('touchend', onDragEnd).on('touchendoutside', onDragEnd)\n        // events for drag move\n        .on('mousemove', onDragMove).on('touchmove', onDragMove);\n\n        _layerGui.addChild(_petAnimation);\n    };\n\n    function moveActions() {\n        var actionTime = 1000;\n        _tweenBgPos = { x: -192 };\n\n        _tweenLeft = new EZGUI.Tween(_tweenBgPos).to({ x: 0 }, actionTime);\n\n        _tweenMid = new EZGUI.Tween(_tweenBgPos).to({ x: -192 }, actionTime);\n\n        _tweenRight = new EZGUI.Tween(_tweenBgPos).to({ x: -384 }, actionTime);\n    };\n\n    function playBgMoveActions() {\n        if (_tweenBgPos.x === -192) {\n            var random = Utils.random(0, 2);\n            if (random > 0) {\n                _tweenLeft.start();\n            } else {\n                _tweenRight.start();\n            }\n        } else {\n            _tweenMid.start();\n        }\n    }\n\n    function petActions() {\n        var actionTime = 1000;\n\n        _tweenPetPos = { y: Conf.Canvas.posY_center + 80, scale: 0.5 };\n\n        _tweenPetFront = new EZGUI.Tween(_tweenPetPos).to({ y: Conf.Canvas.posY_center + 160, scale: 0.60 }, actionTime);\n\n        _tweenPetMid = new EZGUI.Tween(_tweenPetPos).to({ y: Conf.Canvas.posY_center + 80, scale: 0.5 }, actionTime);\n\n        _tweenPetBack = new EZGUI.Tween(_tweenPetPos).to({ y: Conf.Canvas.posY_center, scale: 0.4 }, actionTime);\n    }\n\n    function playPetMoveActions() {\n        if (_tweenPetPos.scale === 0.5) {\n            var random = Utils.random(0, 2);\n            if (random > 0) {\n                _tweenPetFront.start();\n            } else {\n                _tweenPetBack.start();\n            }\n        } else {\n            _tweenPetMid.start();\n        }\n    }\n\n    function playActions() {\n        var random = Utils.random(0, 2);\n        if (random > 0) {\n            playPetMoveActions();\n        } else {\n            playBgMoveActions();\n        }\n    }\n\n    function onDragStart(event) {\n        this.data = event.data;\n        this.dragging = true;\n        //_petAnimation.state.setAnimationByName(0, animations.bathe, true);\n    }\n\n    function onDragEnd() {\n        this.dragging = false;\n        this.data = null;\n        playActions();\n        //_petAnimation.state.setAnimationByName(0, animations.exercise, true);\n    }\n\n    function onDragMove() {\n        if (this.dragging) {\n            //let newPosition = this.data.getLocalPosition(this.parent);\n            //this.position.x = newPosition.x;\n            //this.position.y = newPosition.y + 50;\n        }\n    }\n\n    var animations = {\n        'shopping': 'guangjie',\n        'bathe': 'xizao',\n        'feed': 'weishi',\n        'exercise': 'duanlian'\n    };\n\n    function ClickedOn(event, me) {\n        console.log('EZGUI.components', me.guiID);\n        _petAnimation.state.setAnimationByName(0, animations[me.guiID], true);\n        var data = _actionData[me.guiID];\n        Data.addExp(data.exp);\n    }\n\n    that.inheritOn('update', function (dt) {\n        EZGUI.Tween.update(dt);\n\n        if (_feedTimerButton) _feedTimerButton.update(dt);\n        if (_batheTimerButton) _batheTimerButton.update(dt);\n        if (_shopTimerButton) _shopTimerButton.update(dt);\n        if (_exerciseTimerButton) _exerciseTimerButton.update(dt);\n        if (_gameBgLayer) {\n            _gameBgLayer.position.x = _tweenBgPos.x;\n        }\n        if (_petAnimation) {\n            _petAnimation.position.y = _tweenPetPos.y;\n            _petAnimation.scale.set(_tweenPetPos.scale);\n        }\n    });\n\n    Tools.event.on('levelUp', refreshLayerInfo);\n\n    return that;\n}\nmodule.exports = DemoLayer;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/layers/demo-layer.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/layers/demo-layer.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\n * Created by guolei on 16/3/14.\n */\nvar RendererManager = __webpack_require__(1);\nvar Utils = __webpack_require__(6);\nvar Scale = __webpack_require__(62);\nvar BaseLayer = function BaseLayer(ui_json) {\n    var that = {};\n\n    var stats = new Stats();\n    stats.setMode(1);\n    // align top-left\n    stats.domElement.style.position = 'absolute';\n    stats.domElement.style.left = '0px';\n    stats.domElement.style.top = '0px';\n\n    document.body.appendChild(stats.domElement);\n\n    that.node = new PIXI.Container();\n\n    var _lastTime = 0;\n    var renderer = RendererManager.renderer;\n    Utils.scaleToWindow(renderer, that.node);\n\n    that.clickButton = function (name) {};\n\n    that.init = function () {\n        _lastTime = new Date().getTime();\n        requestAnimationFrame(beforeUpdate);\n    };\n\n    that.update = function (dt) {\n        renderer.render(that.node);\n    };\n\n    function beforeUpdate() {\n        var current = new Date().getTime();\n        var dt = (current - _lastTime) / 1000; // seconds\n        stats.begin();\n        that.update(dt);\n        stats.end();\n        _lastTime = current;\n\n        requestAnimationFrame(beforeUpdate);\n    }\n\n    return that;\n};\n\nmodule.exports = BaseLayer;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/layers/base-layer.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/layers/base-layer.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\n/**\n * Created by guolei on 16/3/21.\n */\nvar Utils = Utils || {};\nvar Spine = __webpack_require__(7).Spine;\n\nUtils.removeRepeat = function (array) {\n    return Array.from(new Set(array));\n};\n\nUtils.random = function (min, max) {\n    return Math.floor(Math.random() * (max - min) + min);\n};\n\nUtils.createSprite = function (g_res) {\n    return new PIXI.Sprite(PIXI.loader.resources[g_res].texture);\n};\n\nUtils.createSpine = function (g_res) {\n    return new Spine(PIXI.loader.resources[g_res].spineData);\n};\n\nUtils.scaleToWindow = function (renderer, stage) {\n    var scaleX = window.innerWidth / 480;\n    var scaleY = window.innerHeight / 754;\n    var scale = Math.min(scaleX, scaleY);\n\n    var width = 480 * scale;\n    var height = 754 * scale;\n\n    var canvas = renderer.view;\n    canvas.style.padding = 0;\n    canvas.style.margin = 0;\n\n    var margin = (window.innerWidth - width) / 2;\n    canvas.style.marginLeft = margin + \"px\";\n    canvas.style.marginRight = margin + \"px\";\n\n    //canvas.style.transformOrigin = \"0 0\";\n    //canvas.style.transform = \"scale(\" + scale + \")\";\n\n    //renderer.autoResize = true;\n    renderer.resize(width, height);\n    stage.scale.x = scale;\n    stage.scale.y = scale;\n};\nmodule.exports = Utils;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/tools/utils.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/tools/utils.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\r\n * @namespace PIXI.spine\r\n */\nmodule.exports = PIXI.spine = {\n    Spine: __webpack_require__(8),\n    SpineRuntime: __webpack_require__(9),\n    loaders: __webpack_require__(53)\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/index.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/index.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(9);\nvar atlasParser = __webpack_require__(51);\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nfunction Spine(spineData) {\n    PIXI.Container.call(this);\n\n    if (!spineData) {\n        throw new Error('The spineData param is required.');\n    }\n\n    if (typeof spineData === \"string\") {\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n\n    /**\n     * The spineData object\n     *\n     * @member {object}\n     */\n    this.spineData = spineData;\n\n    /**\n     * A spine Skeleton object\n     *\n     * @member {object}\n     */\n    this.skeleton = new spine.Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n\n    /**\n     * A spine AnimationStateData object created from the spine data passed in the constructor\n     *\n     * @member {object}\n     */\n    this.stateData = new spine.AnimationStateData(spineData);\n\n    /**\n     * A spine AnimationState object created from the spine AnimationStateData object\n     *\n     * @member {object}\n     */\n    this.state = new spine.AnimationState(this.stateData);\n\n    /**\n     * An array of containers\n     *\n     * @member {Container[]}\n     */\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++) {\n        var slot = this.skeleton.slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.Container();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n\n        if (attachment instanceof spine.RegionAttachment) {\n            var spriteName = attachment.rendererObject.name;\n            var sprite = this.createSprite(slot, attachment);\n            slot.currentSprite = sprite;\n            slot.currentSpriteName = spriteName;\n            slotContainer.addChild(sprite);\n        } else if (attachment instanceof spine.MeshAttachment) {\n            var mesh = this.createMesh(slot, attachment);\n            slot.currentMesh = mesh;\n            slot.currentMeshName = attachment.name;\n            slotContainer.addChild(mesh);\n        } else {\n            continue;\n        }\n    }\n\n    /**\n     * Should the Spine object update its transforms\n     *\n     * @member {boolean}\n     */\n    this.autoUpdate = true;\n}\n\nSpine.fromAtlas = function (resourceName) {\n    var skeletonData = atlasParser.AnimCache[resourceName];\n\n    if (!skeletonData) {\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\n    }\n\n    return new Spine(skeletonData);\n};\n\nSpine.prototype = Object.create(PIXI.Container.prototype);\nSpine.prototype.constructor = Spine;\nmodule.exports = Spine;\n\nSpine.globalAutoUpdate = true;\n\nObject.defineProperties(Spine.prototype, {\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof Spine#\n     * @default true\n     */\n    autoUpdate: {\n        get: function get() {\n            return this.updateTransform === Spine.prototype.autoUpdateTransform;\n        },\n\n        set: function set(value) {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n    }\n});\n\n/**\n * Update the spine skeleton and its animations by delta time (dt)\n *\n * @param dt {number} Delta time. Time by which the animation should be updated\n */\nSpine.prototype.update = function (dt) {\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    var slots = this.skeleton.slots;\n\n    for (var i = 0, n = drawOrder.length; i < n; i++) {\n        this.children[i] = this.slotContainers[drawOrder[i]];\n    }\n\n    for (i = 0, n = slots.length; i < n; i++) {\n        var slot = slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n\n        if (!attachment) {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        var type = attachment.type;\n        if (type === spine.AttachmentType.region) {\n            if (attachment.rendererObject) {\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name) {\n                    var spriteName = attachment.rendererObject.name;\n                    if (slot.currentSprite !== undefined) {\n                        slot.currentSprite.visible = false;\n                    }\n                    slot.sprites = slot.sprites || {};\n                    if (slot.sprites[spriteName] !== undefined) {\n                        slot.sprites[spriteName].visible = true;\n                    } else {\n                        var sprite = this.createSprite(slot, attachment);\n                        slotContainer.addChild(sprite);\n                    }\n                    slot.currentSprite = slot.sprites[spriteName];\n                    slot.currentSpriteName = spriteName;\n                }\n            }\n\n            var bone = slot.bone;\n\n            slotContainer.position.x = bone.worldX + attachment.x * bone.m00 + attachment.y * bone.m01;\n            slotContainer.position.y = bone.worldY + attachment.x * bone.m10 + attachment.y * bone.m11;\n            slotContainer.scale.x = bone.worldScaleX;\n            slotContainer.scale.y = bone.worldScaleY;\n            slotContainer.rotation = -(slot.bone.worldRotation * spine.degRad);\n            if (bone.worldFlipX) {\n                slotContainer.scale.x = -slotContainer.scale.x;\n                slotContainer.rotation = -slotContainer.rotation;\n            }\n            if (bone.worldFlipY == spine.Bone.yDown) {\n                slotContainer.scale.y = -slotContainer.scale.y;\n                slotContainer.rotation = -slotContainer.rotation;\n            }\n            slot.currentSprite.blendMode = slot.blendMode;\n            slot.currentSprite.tint = PIXI.utils.rgb2hex([slot.r, slot.g, slot.b]);\n        } else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh) {\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\n                var meshName = attachment.name;\n                if (slot.currentMesh !== undefined) {\n                    slot.currentMesh.visible = false;\n                }\n\n                slot.meshes = slot.meshes || {};\n\n                if (slot.meshes[meshName] !== undefined) {\n                    slot.meshes[meshName].visible = true;\n                } else {\n                    var mesh = this.createMesh(slot, attachment);\n                    slotContainer.addChild(mesh);\n                }\n\n                slot.currentMesh = slot.meshes[meshName];\n                slot.currentMeshName = meshName;\n            }\n\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\n        } else {\n            slotContainer.visible = false;\n            continue;\n        }\n        slotContainer.visible = true;\n\n        slotContainer.alpha = slot.a;\n    }\n};\n\n/**\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\n *\n * @private\n */\nSpine.prototype.autoUpdateTransform = function () {\n    if (Spine.globalAutoUpdate) {\n        this.lastTime = this.lastTime || Date.now();\n        var timeDelta = (Date.now() - this.lastTime) * 0.001;\n        this.lastTime = Date.now();\n        this.update(timeDelta);\n    } else {\n        this.lastTime = 0;\n    }\n\n    PIXI.Container.prototype.updateTransform.call(this);\n};\n\n/**\n * Create a new sprite to be used with spine.RegionAttachment\n *\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createSprite = function (slot, attachment) {\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var spriteRect = new PIXI.Rectangle(descriptor.x, descriptor.y, descriptor.rotate ? descriptor.height : descriptor.width, descriptor.rotate ? descriptor.width : descriptor.height);\n    var spriteTexture = new PIXI.Texture(baseTexture, spriteRect);\n    var sprite = new PIXI.Sprite(spriteTexture);\n\n    var baseRotation = descriptor.rotate ? Math.PI * 0.5 : 0.0;\n    sprite.scale.x = attachment.width / descriptor.originalWidth * attachment.scaleX;\n    sprite.scale.y = attachment.height / descriptor.originalHeight * attachment.scaleY;\n    sprite.rotation = baseRotation - attachment.rotation * spine.degRad;\n    sprite.anchor.x = (0.5 * descriptor.originalWidth - descriptor.offsetX) / descriptor.width;\n    sprite.anchor.y = 1.0 - (0.5 * descriptor.originalHeight - descriptor.offsetY) / descriptor.height;\n    sprite.alpha = attachment.a;\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\n/**\n * Creates a Strip from the spine data\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createMesh = function (slot, attachment) {\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var texture = new PIXI.Texture(baseTexture);\n\n    var strip = new PIXI.mesh.Mesh(texture, new Float32Array(attachment.uvs.length), new Float32Array(attachment.uvs), new Uint16Array(attachment.triangles), PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n    strip.canvasPadding = 1.5;\n\n    strip.alpha = attachment.a;\n\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.name] = strip;\n\n    return strip;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/Spine/index.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/Spine/index.js?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.1\n *\n * Copyright (c) 2013, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable and\n * non-transferable license to install, execute and perform the Spine Runtimes\n * Software (the \"Software\") solely for internal use. Without the written\n * permission of Esoteric Software (typically granted by licensing Spine), you\n * may not (a) modify, translate, adapt or otherwise create derivative works,\n * improvements of the Software or develop new applications using the Software\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\n * trademark, patent or other intellectual property or proprietary rights\n * notices on or in the Software, including any copy thereof. Redistributions\n * in binary or source form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\nvar spine = __webpack_require__(10);\nspine.Animation = __webpack_require__(11);\nspine.AnimationStateData = __webpack_require__(12);\nspine.AnimationState = __webpack_require__(13);\nspine.AtlasAttachmentParser = __webpack_require__(15);\nspine.Atlas = __webpack_require__(21);\nspine.AtlasPage = __webpack_require__(23);\nspine.AtlasReader = __webpack_require__(22);\nspine.AtlasRegion = __webpack_require__(24);\nspine.AttachmentTimeline = __webpack_require__(26);\nspine.AttachmentType = __webpack_require__(17);\nspine.BoneData = __webpack_require__(28);\nspine.Bone = __webpack_require__(29);\nspine.BoundingBoxAttachment = __webpack_require__(20);\nspine.ColorTimeline = __webpack_require__(30);\nspine.Curves = __webpack_require__(27);\nspine.DrawOrderTimeline = __webpack_require__(31);\nspine.EventData = __webpack_require__(32);\nspine.Event = __webpack_require__(33);\nspine.EventTimeline = __webpack_require__(34);\nspine.FfdTimeline = __webpack_require__(35);\nspine.FlipXTimeline = __webpack_require__(36);\nspine.FlipYTimeline = __webpack_require__(37);\nspine.IkConstraintData = __webpack_require__(38);\nspine.IkConstraint = __webpack_require__(39);\nspine.IkConstraintTimeline = __webpack_require__(40);\nspine.MeshAttachment = __webpack_require__(18);\nspine.RegionAttachment = __webpack_require__(16);\nspine.RotateTimeline = __webpack_require__(41);\nspine.ScaleTimeline = __webpack_require__(42);\nspine.SkeletonBounds = __webpack_require__(43);\nspine.SkeletonData = __webpack_require__(44);\nspine.Skeleton = __webpack_require__(45);\nspine.SkeletonJsonParser = __webpack_require__(47);\nspine.Skin = __webpack_require__(49);\nspine.SkinnedMeshAttachment = __webpack_require__(19);\nspine.SlotData = __webpack_require__(48);\nspine.Slot = __webpack_require__(46);\nspine.TrackEntry = __webpack_require__(14);\nspine.TranslateTimeline = __webpack_require__(50);\nmodule.exports = spine;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/index.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/index.js?");

/***/ },
/* 10 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = {\n    radDeg: 180 / Math.PI,\n    degRad: Math.PI / 180,\n    temp: [],\n    Float32Array: typeof Float32Array === 'undefined' ? Array : Float32Array,\n    Uint16Array: typeof Uint16Array === 'undefined' ? Array : Uint16Array\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineUtil/index.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineUtil/index.js?");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Animation = function (name, timelines, duration) {\n    this.name = name;\n    this.timelines = timelines;\n    this.duration = duration;\n};\nspine.Animation.prototype = {\n    apply: function apply(skeleton, lastTime, time, loop, events) {\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            lastTime %= this.duration;\n        }\n        var timelines = this.timelines;\n        for (var i = 0, n = timelines.length; i < n; i++) {\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\n        }\n    },\n    mix: function mix(skeleton, lastTime, time, loop, events, alpha) {\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            lastTime %= this.duration;\n        }\n        var timelines = this.timelines;\n        for (var i = 0, n = timelines.length; i < n; i++) {\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\n        }\n    }\n};\nspine.Animation.binarySearch = function (values, target, step) {\n    var low = 0;\n    var high = Math.floor(values.length / step) - 2;\n    if (!high) return step;\n    var current = high >>> 1;\n    while (true) {\n        if (values[(current + 1) * step] <= target) low = current + 1;else high = current;\n        if (low == high) return (low + 1) * step;\n        current = low + high >>> 1;\n    }\n};\nspine.Animation.binarySearch1 = function (values, target) {\n    var low = 0;\n    var high = values.length - 2;\n    if (!high) return 1;\n    var current = high >>> 1;\n    while (true) {\n        if (values[current + 1] <= target) low = current + 1;else high = current;\n        if (low == high) return low + 1;\n        current = low + high >>> 1;\n    }\n};\nspine.Animation.linearSearch = function (values, target, step) {\n    for (var i = 0, last = values.length - step; i <= last; i += step) {\n        if (values[i] > target) return i;\n    }return -1;\n};\nmodule.exports = spine.Animation;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/Animation.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/Animation.js?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar spine = __webpack_require__(10);\nspine.AnimationStateData = function (skeletonData) {\n    this.skeletonData = skeletonData;\n    this.animationToMixTime = {};\n};\nspine.AnimationStateData.prototype = {\n    defaultMix: 0,\n    setMixByName: function setMixByName(fromName, toName, duration) {\n        var from = this.skeletonData.findAnimation(fromName);\n        if (!from) throw \"Animation not found: \" + fromName;\n        var to = this.skeletonData.findAnimation(toName);\n        if (!to) throw \"Animation not found: \" + toName;\n        this.setMix(from, to, duration);\n    },\n    setMix: function setMix(from, to, duration) {\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\n    },\n    getMix: function getMix(from, to) {\n        var key = from.name + \":\" + to.name;\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\n    }\n};\nmodule.exports = spine.AnimationStateData;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/AnimationStateData.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/AnimationStateData.js?");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.TrackEntry = __webpack_require__(14);\nspine.AnimationState = function (stateData) {\n    this.data = stateData;\n    this.tracks = [];\n    this.events = [];\n};\nspine.AnimationState.prototype = {\n    onStart: null,\n    onEnd: null,\n    onComplete: null,\n    onEvent: null,\n    timeScale: 1,\n    update: function update(delta) {\n        delta *= this.timeScale;\n        for (var i = 0; i < this.tracks.length; i++) {\n            var current = this.tracks[i];\n            if (!current) continue;\n\n            current.time += delta * current.timeScale;\n            if (current.previous) {\n                var previousDelta = delta * current.previous.timeScale;\n                current.previous.time += previousDelta;\n                current.mixTime += previousDelta;\n            }\n\n            var next = current.next;\n            if (next) {\n                next.time = current.lastTime - next.delay;\n                if (next.time >= 0) this.setCurrent(i, next);\n            } else {\n                // End non-looping animation when it reaches its end time and there is no next entry.\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\n            }\n        }\n    },\n    apply: function apply(skeleton) {\n        skeleton.resetDrawOrder();\n\n        for (var i = 0; i < this.tracks.length; i++) {\n            var current = this.tracks[i];\n            if (!current) continue;\n\n            this.events.length = 0;\n\n            var time = current.time;\n            var lastTime = current.lastTime;\n            var endTime = current.endTime;\n            var loop = current.loop;\n            if (!loop && time > endTime) time = endTime;\n\n            var previous = current.previous;\n            if (!previous) {\n                if (current.mix == 1) current.animation.apply(skeleton, current.lastTime, time, loop, this.events);else current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\n            } else {\n                var previousTime = previous.time;\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\n\n                var alpha = current.mixTime / current.mixDuration * current.mix;\n                if (alpha >= 1) {\n                    alpha = 1;\n                    current.previous = null;\n                }\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\n            }\n\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++) {\n                var event = this.events[ii];\n                if (current.onEvent) current.onEvent(i, event);\n                if (this.onEvent) this.onEvent(i, event);\n            }\n\n            // Check if completed the animation or a loop iteration.\n            if (loop ? lastTime % endTime > time % endTime : lastTime < endTime && time >= endTime) {\n                var count = Math.floor(time / endTime);\n                if (current.onComplete) current.onComplete(i, count);\n                if (this.onComplete) this.onComplete(i, count);\n            }\n\n            current.lastTime = current.time;\n        }\n    },\n    clearTracks: function clearTracks() {\n        for (var i = 0, n = this.tracks.length; i < n; i++) {\n            this.clearTrack(i);\n        }this.tracks.length = 0;\n    },\n    clearTrack: function clearTrack(trackIndex) {\n        if (trackIndex >= this.tracks.length) return;\n        var current = this.tracks[trackIndex];\n        if (!current) return;\n\n        if (current.onEnd) current.onEnd(trackIndex);\n        if (this.onEnd) this.onEnd(trackIndex);\n\n        this.tracks[trackIndex] = null;\n    },\n    _expandToIndex: function _expandToIndex(index) {\n        if (index < this.tracks.length) return this.tracks[index];\n        while (index >= this.tracks.length) {\n            this.tracks.push(null);\n        }return null;\n    },\n    setCurrent: function setCurrent(index, entry) {\n        var current = this._expandToIndex(index);\n        if (current) {\n            var previous = current.previous;\n            current.previous = null;\n\n            if (current.onEnd) current.onEnd(index);\n            if (this.onEnd) this.onEnd(index);\n\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\n            if (entry.mixDuration > 0) {\n                entry.mixTime = 0;\n                // If a mix is in progress, mix from the closest animation.\n                if (previous && current.mixTime / current.mixDuration < 0.5) entry.previous = previous;else entry.previous = current;\n            }\n        }\n\n        this.tracks[index] = entry;\n\n        if (entry.onStart) entry.onStart(index);\n        if (this.onStart) this.onStart(index);\n    },\n    setAnimationByName: function setAnimationByName(trackIndex, animationName, loop) {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        return this.setAnimation(trackIndex, animation, loop);\n    },\n    /** Set the current animation. Any queued animations are cleared. */\n    setAnimation: function setAnimation(trackIndex, animation, loop) {\n        var entry = new spine.TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n        this.setCurrent(trackIndex, entry);\n        return entry;\n    },\n    addAnimationByName: function addAnimationByName(trackIndex, animationName, loop, delay) {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        return this.addAnimation(trackIndex, animation, loop, delay);\n    },\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\r\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\n    addAnimation: function addAnimation(trackIndex, animation, loop, delay) {\n        var entry = new spine.TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n\n        var last = this._expandToIndex(trackIndex);\n        if (last) {\n            while (last.next) {\n                last = last.next;\n            }last.next = entry;\n        } else this.tracks[trackIndex] = entry;\n\n        if (delay <= 0) {\n            if (last) delay += last.endTime - this.data.getMix(last.animation, animation);else delay = 0;\n        }\n        entry.delay = delay;\n\n        return entry;\n    },\n    /** May be null. */\n    getCurrent: function getCurrent(trackIndex) {\n        if (trackIndex >= this.tracks.length) return null;\n        return this.tracks[trackIndex];\n    }\n};\nmodule.exports = spine.AnimationState;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/AnimationState.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/AnimationState.js?");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.TrackEntry = function () {};\nspine.TrackEntry.prototype = {\n    next: null, previous: null,\n    animation: null,\n    loop: false,\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\n    timeScale: 1,\n    mixTime: 0, mixDuration: 0, mix: 1,\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\n};\nmodule.exports = spine.TrackEntry;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/TrackEntry.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/TrackEntry.js?");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.RegionAttachment = __webpack_require__(16);\nspine.MeshAttachment = __webpack_require__(18);\nspine.SkinnedMeshAttachment = __webpack_require__(19);\nspine.BoundingBoxAttachment = __webpack_require__(20);\nspine.AtlasAttachmentParser = function (atlas) {\n    this.atlas = atlas;\n};\nspine.AtlasAttachmentParser.prototype = {\n    newRegionAttachment: function newRegionAttachment(skin, name, path) {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\n        var attachment = new spine.RegionAttachment(name);\n        attachment.rendererObject = region;\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.offsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newMeshAttachment: function newMeshAttachment(skin, name, path) {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\n        var attachment = new spine.MeshAttachment(name);\n        attachment.rendererObject = region;\n        attachment.regionU = region.u;\n        attachment.regionV = region.v;\n        attachment.regionU2 = region.u2;\n        attachment.regionV2 = region.v2;\n        attachment.regionRotate = region.rotate;\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.offsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newSkinnedMeshAttachment: function newSkinnedMeshAttachment(skin, name, path) {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\n        var attachment = new spine.SkinnedMeshAttachment(name);\n        attachment.rendererObject = region;\n        attachment.regionU = region.u;\n        attachment.regionV = region.v;\n        attachment.regionU2 = region.u2;\n        attachment.regionV2 = region.v2;\n        attachment.regionRotate = region.rotate;\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.offsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newBoundingBoxAttachment: function newBoundingBoxAttachment(skin, name) {\n        return new spine.BoundingBoxAttachment(name);\n    }\n};\nmodule.exports = spine.AtlasAttachmentParser;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/AtlasAttachmentParser.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/AtlasAttachmentParser.js?");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.AttachmentType = __webpack_require__(17);\nspine.RegionAttachment = function (name) {\n    this.name = name;\n    this.offset = [];\n    this.offset.length = 8;\n    this.uvs = [];\n    this.uvs.length = 8;\n};\nspine.RegionAttachment.prototype = {\n    type: spine.AttachmentType.region,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    width: 0, height: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    setUVs: function setUVs(u, v, u2, v2, rotate) {\n        var uvs = this.uvs;\n        if (rotate) {\n            uvs[2 /*X2*/] = u;\n            uvs[3 /*Y2*/] = v2;\n            uvs[4 /*X3*/] = u;\n            uvs[5 /*Y3*/] = v;\n            uvs[6 /*X4*/] = u2;\n            uvs[7 /*Y4*/] = v;\n            uvs[0 /*X1*/] = u2;\n            uvs[1 /*Y1*/] = v2;\n        } else {\n            uvs[0 /*X1*/] = u;\n            uvs[1 /*Y1*/] = v2;\n            uvs[2 /*X2*/] = u;\n            uvs[3 /*Y2*/] = v;\n            uvs[4 /*X3*/] = u2;\n            uvs[5 /*Y3*/] = v;\n            uvs[6 /*X4*/] = u2;\n            uvs[7 /*Y4*/] = v2;\n        }\n    },\n    updateOffset: function updateOffset() {\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\n        var localX2 = localX + this.regionWidth * regionScaleX;\n        var localY2 = localY + this.regionHeight * regionScaleY;\n        var radians = this.rotation * spine.degRad;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var localXCos = localX * cos + this.x;\n        var localXSin = localX * sin;\n        var localYCos = localY * cos + this.y;\n        var localYSin = localY * sin;\n        var localX2Cos = localX2 * cos + this.x;\n        var localX2Sin = localX2 * sin;\n        var localY2Cos = localY2 * cos + this.y;\n        var localY2Sin = localY2 * sin;\n        var offset = this.offset;\n        offset[0 /*X1*/] = localXCos - localYSin;\n        offset[1 /*Y1*/] = localYCos + localXSin;\n        offset[2 /*X2*/] = localXCos - localY2Sin;\n        offset[3 /*Y2*/] = localY2Cos + localXSin;\n        offset[4 /*X3*/] = localX2Cos - localY2Sin;\n        offset[5 /*Y3*/] = localY2Cos + localX2Sin;\n        offset[6 /*X4*/] = localX2Cos - localYSin;\n        offset[7 /*Y4*/] = localYCos + localX2Sin;\n    },\n    computeVertices: function computeVertices(x, y, bone, vertices) {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.m00,\n            m01 = bone.m01,\n            m10 = bone.m10,\n            m11 = bone.m11;\n        var offset = this.offset;\n        vertices[0 /*X1*/] = offset[0 /*X1*/] * m00 + offset[1 /*Y1*/] * m01 + x;\n        vertices[1 /*Y1*/] = offset[0 /*X1*/] * m10 + offset[1 /*Y1*/] * m11 + y;\n        vertices[2 /*X2*/] = offset[2 /*X2*/] * m00 + offset[3 /*Y2*/] * m01 + x;\n        vertices[3 /*Y2*/] = offset[2 /*X2*/] * m10 + offset[3 /*Y2*/] * m11 + y;\n        vertices[4 /*X3*/] = offset[4 /*X3*/] * m00 + offset[5 /*X3*/] * m01 + x;\n        vertices[5 /*X3*/] = offset[4 /*X3*/] * m10 + offset[5 /*X3*/] * m11 + y;\n        vertices[6 /*X4*/] = offset[6 /*X4*/] * m00 + offset[7 /*Y4*/] * m01 + x;\n        vertices[7 /*Y4*/] = offset[6 /*X4*/] * m10 + offset[7 /*Y4*/] * m11 + y;\n    }\n};\nmodule.exports = spine.RegionAttachment;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/RegionAttachment.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/RegionAttachment.js?");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.AttachmentType = {\n    region: 0,\n    boundingbox: 1,\n    mesh: 2,\n    skinnedmesh: 3\n};\nmodule.exports = spine.AttachmentType;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/AttachmentType.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/AttachmentType.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10) || {};\nspine.AttachmentType = __webpack_require__(17);\nspine.MeshAttachment = function (name) {\n    this.name = name;\n};\nspine.MeshAttachment.prototype = {\n    type: spine.AttachmentType.mesh,\n    vertices: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function updateUVs() {\n        var width = this.regionU2 - this.regionU,\n            height = this.regionV2 - this.regionV;\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n) {\n            this.uvs = new spine.Float32Array(n);\n        }\n        if (this.regionRotate) {\n            for (var i = 0; i < n; i += 2) {\n                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;\n                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;\n            }\n        } else {\n            for (var i = 0; i < n; i += 2) {\n                this.uvs[i] = this.regionU + this.regionUVs[i] * width;\n                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;\n            }\n        }\n    },\n    computeWorldVertices: function computeWorldVertices(x, y, slot, worldVertices) {\n        var bone = slot.bone;\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.m00,\n            m01 = bone.m01,\n            m10 = bone.m10,\n            m11 = bone.m11;\n        var vertices = this.vertices;\n        var verticesCount = vertices.length;\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\n        for (var i = 0; i < verticesCount; i += 2) {\n            var vx = vertices[i];\n            var vy = vertices[i + 1];\n            worldVertices[i] = vx * m00 + vy * m01 + x;\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\n        }\n    }\n};\nmodule.exports = spine.MeshAttachment;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/MeshAttachment.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/MeshAttachment.js?");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10) || {};\nspine.AttachmentType = __webpack_require__(17);\nspine.SkinnedMeshAttachment = function (name) {\n    this.name = name;\n};\nspine.SkinnedMeshAttachment.prototype = {\n    type: spine.AttachmentType.skinnedmesh,\n    bones: null,\n    weights: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionU: 0, regionV: 0, regionU2: 0, regionV2: 0, regionRotate: false,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function updateUVs(u, v, u2, v2, rotate) {\n        var width = this.regionU2 - this.regionU,\n            height = this.regionV2 - this.regionV;\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n) {\n            this.uvs = new spine.Float32Array(n);\n        }\n        if (this.regionRotate) {\n            for (var i = 0; i < n; i += 2) {\n                this.uvs[i] = this.regionU + this.regionUVs[i + 1] * width;\n                this.uvs[i + 1] = this.regionV + height - this.regionUVs[i] * height;\n            }\n        } else {\n            for (var i = 0; i < n; i += 2) {\n                this.uvs[i] = this.regionU + this.regionUVs[i] * width;\n                this.uvs[i + 1] = this.regionV + this.regionUVs[i + 1] * height;\n            }\n        }\n    },\n    computeWorldVertices: function computeWorldVertices(x, y, slot, worldVertices) {\n        var skeletonBones = slot.bone.skeleton.bones;\n        var weights = this.weights;\n        var bones = this.bones;\n\n        var w = 0,\n            v = 0,\n            b = 0,\n            f = 0,\n            n = bones.length,\n            nn;\n        var wx, wy, bone, vx, vy, weight;\n        if (!slot.attachmentVertices.length) {\n            for (; v < n; w += 2) {\n                wx = 0;\n                wy = 0;\n                nn = bones[v++] + v;\n                for (; v < nn; v++, b += 3) {\n                    bone = skeletonBones[bones[v]];\n                    vx = weights[b];\n                    vy = weights[b + 1];\n                    weight = weights[b + 2];\n                    wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;\n                    wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;\n                }\n                worldVertices[w] = wx + x;\n                worldVertices[w + 1] = wy + y;\n            }\n        } else {\n            var ffd = slot.attachmentVertices;\n            for (; v < n; w += 2) {\n                wx = 0;\n                wy = 0;\n                nn = bones[v++] + v;\n                for (; v < nn; v++, b += 3, f += 2) {\n                    bone = skeletonBones[bones[v]];\n                    vx = weights[b] + ffd[f];\n                    vy = weights[b + 1] + ffd[f + 1];\n                    weight = weights[b + 2];\n                    wx += (vx * bone.m00 + vy * bone.m01 + bone.worldX) * weight;\n                    wy += (vx * bone.m10 + vy * bone.m11 + bone.worldY) * weight;\n                }\n                worldVertices[w] = wx + x;\n                worldVertices[w + 1] = wy + y;\n            }\n        }\n    }\n};\nmodule.exports = spine.SkinnedMeshAttachment;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/SkinnedMeshAttachment.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/SkinnedMeshAttachment.js?");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.AttachmentType = __webpack_require__(17);\nspine.BoundingBoxAttachment = function (name) {\n    this.name = name;\n    this.vertices = [];\n};\nspine.BoundingBoxAttachment.prototype = {\n    type: spine.AttachmentType.boundingbox,\n    computeWorldVertices: function computeWorldVertices(x, y, bone, worldVertices) {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.m00,\n            m01 = bone.m01,\n            m10 = bone.m10,\n            m11 = bone.m11;\n        var vertices = this.vertices;\n        for (var i = 0, n = vertices.length; i < n; i += 2) {\n            var px = vertices[i];\n            var py = vertices[i + 1];\n            worldVertices[i] = px * m00 + py * m01 + x;\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\n        }\n    }\n};\nmodule.exports = spine.BoundingBoxAttachment;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/BoundingBoxAttachment.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/BoundingBoxAttachment.js?");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.AtlasReader = __webpack_require__(22);\nspine.AtlasPage = __webpack_require__(23);\nspine.AtlasRegion = __webpack_require__(24);\nvar syncImageLoaderAdapter = __webpack_require__(25);\n\nspine.Atlas = function (atlasText, loaderFunction, callback) {\n    //TODO: remove this legacy later\n    if (typeof loaderFunction !== \"function\") {\n        //old syntax\n        var baseUrl = loaderFunction;\n        var crossOrigin = callback;\n        loaderFunction = syncImageLoaderAdapter(baseUrl, crossOrigin);\n        callback = null;\n    }\n\n    this.pages = [];\n    this.regions = [];\n\n    this.texturesLoading = 0;\n\n    var self = this;\n\n    var reader = new spine.AtlasReader(atlasText);\n    var tuple = [];\n    tuple.length = 4;\n    var page = null;\n\n    iterateParser();\n\n    function iterateParser() {\n        while (true) {\n            var line = reader.readLine();\n            if (line === null) {\n                return callback && callback(self);\n            }\n            line = reader.trim(line);\n            if (!line.length) page = null;else if (!page) {\n                page = new spine.AtlasPage();\n                page.name = line;\n\n                if (reader.readTuple(tuple) == 2) {\n                    // size is only optional for an atlas packed with an old TexturePacker.\n                    page.width = parseInt(tuple[0]);\n                    page.height = parseInt(tuple[1]);\n                    reader.readTuple(tuple);\n                } else {\n                    //old format, detect width and height by texture\n                }\n                page.format = spine.Atlas.Format[tuple[0]];\n\n                reader.readTuple(tuple);\n                page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\n                page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\n\n                var direction = reader.readValue();\n                page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\n                page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\n                if (direction == \"x\") page.uWrap = spine.Atlas.TextureWrap.repeat;else if (direction == \"y\") page.vWrap = spine.Atlas.TextureWrap.repeat;else if (direction == \"xy\") page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\n\n                // @ivanpopelyshev: I so want to use generators and \"yield()\" here, or at least promises\n                loaderFunction(line, function (texture) {\n                    page.rendererObject = texture;\n                    self.pages.push(page);\n                    if (!page.width || !page.height) {\n                        page.width = texture.width;\n                        page.height = texture.height;\n                        if (!page.width || !page.height) {\n                            console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n                        }\n                    }\n                    iterateParser();\n                });\n                break;\n            } else {\n                var region = new spine.AtlasRegion();\n                region.name = line;\n                region.page = page;\n\n                region.rotate = reader.readValue() == \"true\";\n\n                reader.readTuple(tuple);\n                var x = parseInt(tuple[0]);\n                var y = parseInt(tuple[1]);\n\n                reader.readTuple(tuple);\n                var width = parseInt(tuple[0]);\n                var height = parseInt(tuple[1]);\n\n                region.u = x / page.width;\n                region.v = y / page.height;\n                if (region.rotate) {\n                    region.u2 = (x + height) / page.width;\n                    region.v2 = (y + width) / page.height;\n                } else {\n                    region.u2 = (x + width) / page.width;\n                    region.v2 = (y + height) / page.height;\n                }\n                //detected resolution\n                var resolution = page.rendererObject.resolution;\n                region.x = x / resolution;\n                region.y = y / resolution;\n                region.width = Math.abs(width) / resolution;\n                region.height = Math.abs(height) / resolution;\n\n                if (reader.readTuple(tuple) == 4) {\n                    // split is optional\n                    region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\n\n                    if (reader.readTuple(tuple) == 4) {\n                        // pad is optional, but only present with splits\n                        region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\n\n                        reader.readTuple(tuple);\n                    }\n                }\n\n                region.originalWidth = parseInt(tuple[0]) / resolution;\n                region.originalHeight = parseInt(tuple[1]) / resolution;\n\n                reader.readTuple(tuple);\n                region.offsetX = parseInt(tuple[0]) / resolution;\n                region.offsetY = parseInt(tuple[1]) / resolution;\n\n                region.index = parseInt(reader.readValue());\n\n                self.regions.push(region);\n            }\n        }\n    }\n};\nspine.Atlas.prototype = {\n    findRegion: function findRegion(name) {\n        var regions = this.regions;\n        for (var i = 0, n = regions.length; i < n; i++) {\n            if (regions[i].name == name) return regions[i];\n        }return null;\n    },\n    dispose: function dispose() {\n        var pages = this.pages;\n        for (var i = 0, n = pages.length; i < n; i++) {\n            pages[i].rendererObject.destroy(true);\n        }\n    },\n    updateUVs: function updateUVs(page) {\n        var regions = this.regions;\n        for (var i = 0, n = regions.length; i < n; i++) {\n            var region = regions[i];\n            if (region.page != page) continue;\n            region.u = region.x / page.width;\n            region.v = region.y / page.height;\n            if (region.rotate) {\n                region.u2 = (region.x + region.height) / page.width;\n                region.v2 = (region.y + region.width) / page.height;\n            } else {\n                region.u2 = (region.x + region.width) / page.width;\n                region.v2 = (region.y + region.height) / page.height;\n            }\n        }\n    }\n};\n\nspine.Atlas.Format = {\n    alpha: 0,\n    intensity: 1,\n    luminanceAlpha: 2,\n    rgb565: 3,\n    rgba4444: 4,\n    rgb888: 5,\n    rgba8888: 6\n};\n\nspine.Atlas.TextureFilter = {\n    nearest: 0,\n    linear: 1,\n    mipMap: 2,\n    mipMapNearestNearest: 3,\n    mipMapLinearNearest: 4,\n    mipMapNearestLinear: 5,\n    mipMapLinearLinear: 6\n};\n\nspine.Atlas.TextureWrap = {\n    mirroredRepeat: 0,\n    clampToEdge: 1,\n    repeat: 2\n};\nmodule.exports = spine.Atlas;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/Atlas.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/Atlas.js?");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar spine = __webpack_require__(10);\nspine.AtlasReader = function (text) {\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\n};\nspine.AtlasReader.prototype = {\n    index: 0,\n    trim: function trim(value) {\n        return value.replace(/^\\s+|\\s+$/g, \"\");\n    },\n    readLine: function readLine() {\n        if (this.index >= this.lines.length) return null;\n        return this.lines[this.index++];\n    },\n    readValue: function readValue() {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw \"Invalid line: \" + line;\n        return this.trim(line.substring(colon + 1));\n    },\n    /** Returns the number of tuple values read (1, 2 or 4). */\n    readTuple: function readTuple(tuple) {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw \"Invalid line: \" + line;\n        var i = 0,\n            lastMatch = colon + 1;\n        for (; i < 3; i++) {\n            var comma = line.indexOf(\",\", lastMatch);\n            if (comma == -1) break;\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\n            lastMatch = comma + 1;\n        }\n        tuple[i] = this.trim(line.substring(lastMatch));\n        return i + 1;\n    }\n};\nmodule.exports = spine.AtlasReader;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/AtlasReader.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/AtlasReader.js?");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.AtlasPage = function () {};\nspine.AtlasPage.prototype = {\n    name: null,\n    format: null,\n    minFilter: null,\n    magFilter: null,\n    uWrap: null,\n    vWrap: null,\n    rendererObject: null,\n    width: 0,\n    height: 0\n};\nmodule.exports = spine.AtlasPage;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/AtlasPage.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/AtlasPage.js?");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.AtlasRegion = function () {};\nspine.AtlasRegion.prototype = {\n    page: null,\n    name: null,\n    x: 0, y: 0,\n    width: 0, height: 0,\n    u: 0, v: 0, u2: 0, v2: 0,\n    offsetX: 0, offsetY: 0,\n    originalWidth: 0, originalHeight: 0,\n    index: 0,\n    rotate: false,\n    splits: null,\n    pads: null\n};\nmodule.exports = spine.AtlasRegion;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/AtlasRegion.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/AtlasRegion.js?");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(9);\n\nmodule.exports = function (baseUrl, crossOrigin) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {\n        baseUrl += '/';\n    }\n    return function (line, callback) {\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\n    };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/loaders/syncImageLoaderAdapter.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/loaders/syncImageLoaderAdapter.js?");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Curves = __webpack_require__(27);\nspine.Animation = __webpack_require__(11);\nspine.AttachmentTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.attachmentNames = [];\n    this.attachmentNames.length = frameCount;\n};\nspine.AttachmentTimeline.prototype = {\n    slotIndex: 0,\n    getFrameCount: function getFrameCount() {\n        return this.frames.length;\n    },\n    setFrame: function setFrame(frameIndex, time, attachmentName) {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    },\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) {\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\n            return;\n        } else if (lastTime > time) //\n            lastTime = -1;\n\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\n        if (frames[frameIndex] < lastTime) return;\n\n        var attachmentName = this.attachmentNames[frameIndex];\n        skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\n    }\n};\nmodule.exports = spine.AttachmentTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/AttachmentTimeline.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/AttachmentTimeline.js?");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Curves = function (frameCount) {\n    this.curves = []; // type, x, y, ...\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\n};\nspine.Curves.prototype = {\n    setLinear: function setLinear(frameIndex) {\n        this.curves[frameIndex * 19 /*BEZIER_SIZE*/] = 0 /*LINEAR*/;\n    },\n    setStepped: function setStepped(frameIndex) {\n        this.curves[frameIndex * 19 /*BEZIER_SIZE*/] = 1 /*STEPPED*/;\n    },\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\n    setCurve: function setCurve(frameIndex, cx1, cy1, cx2, cy2) {\n        var subdiv1 = 1 / 10 /*BEZIER_SEGMENTS*/,\n            subdiv2 = subdiv1 * subdiv1,\n            subdiv3 = subdiv2 * subdiv1;\n        var pre1 = 3 * subdiv1,\n            pre2 = 3 * subdiv2,\n            pre4 = 6 * subdiv2,\n            pre5 = 6 * subdiv3;\n        var tmp1x = -cx1 * 2 + cx2,\n            tmp1y = -cy1 * 2 + cy2,\n            tmp2x = (cx1 - cx2) * 3 + 1,\n            tmp2y = (cy1 - cy2) * 3 + 1;\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3,\n            dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\n        var ddfx = tmp1x * pre4 + tmp2x * pre5,\n            ddfy = tmp1y * pre4 + tmp2y * pre5;\n        var dddfx = tmp2x * pre5,\n            dddfy = tmp2y * pre5;\n\n        var i = frameIndex * 19 /*BEZIER_SIZE*/;\n        var curves = this.curves;\n        curves[i++] = 2 /*BEZIER*/;\n\n        var x = dfx,\n            y = dfy;\n        for (var n = i + 19 /*BEZIER_SIZE*/ - 1; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n    },\n    getCurvePercent: function getCurvePercent(frameIndex, percent) {\n        percent = percent < 0 ? 0 : percent > 1 ? 1 : percent;\n        var curves = this.curves;\n        var i = frameIndex * 19 /*BEZIER_SIZE*/;\n        var type = curves[i];\n        if (type === 0 /*LINEAR*/) return percent;\n        if (type == 1 /*STEPPED*/) return 0;\n        i++;\n        var x = 0;\n        for (var start = i, n = i + 19 /*BEZIER_SIZE*/ - 1; i < n; i += 2) {\n            x = curves[i];\n            if (x >= percent) {\n                var prevX, prevY;\n                if (i == start) {\n                    prevX = 0;\n                    prevY = 0;\n                } else {\n                    prevX = curves[i - 2];\n                    prevY = curves[i - 1];\n                }\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n            }\n        }\n        var y = curves[i - 1];\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n    }\n};\nmodule.exports = spine.Curves;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/Curves.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/Curves.js?");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.BoneData = function (name, parent) {\n    this.name = name;\n    this.parent = parent;\n};\nspine.BoneData.prototype = {\n    length: 0,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    inheritScale: true,\n    inheritRotation: true,\n    flipX: false, flipY: false\n};\nmodule.exports = spine.BoneData;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/BoneData.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/BoneData.js?");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Bone = function (boneData, skeleton, parent) {\n    this.data = boneData;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.setToSetupPose();\n};\nspine.Bone.yDown = false;\nspine.Bone.prototype = {\n    x: 0, y: 0,\n    rotation: 0, rotationIK: 0,\n    scaleX: 1, scaleY: 1,\n    flipX: false, flipY: false,\n    m00: 0, m01: 0, worldX: 0, // a b x\n    m10: 0, m11: 0, worldY: 0, // c d y\n    worldRotation: 0,\n    worldScaleX: 1, worldScaleY: 1,\n    worldFlipX: false, worldFlipY: false,\n    updateWorldTransform: function updateWorldTransform() {\n        var parent = this.parent;\n        if (parent) {\n            this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;\n            this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;\n            if (this.data.inheritScale) {\n                this.worldScaleX = parent.worldScaleX * this.scaleX;\n                this.worldScaleY = parent.worldScaleY * this.scaleY;\n            } else {\n                this.worldScaleX = this.scaleX;\n                this.worldScaleY = this.scaleY;\n            }\n            this.worldRotation = this.data.inheritRotation ? parent.worldRotation + this.rotationIK : this.rotationIK;\n            this.worldFlipX = parent.worldFlipX != this.flipX;\n            this.worldFlipY = parent.worldFlipY != this.flipY;\n        } else {\n            var skeletonFlipX = this.skeleton.flipX,\n                skeletonFlipY = this.skeleton.flipY;\n            this.worldX = skeletonFlipX ? -this.x : this.x;\n            this.worldY = skeletonFlipY != spine.Bone.yDown ? -this.y : this.y;\n            this.worldScaleX = this.scaleX;\n            this.worldScaleY = this.scaleY;\n            this.worldRotation = this.rotationIK;\n            this.worldFlipX = skeletonFlipX != this.flipX;\n            this.worldFlipY = skeletonFlipY != this.flipY;\n        }\n        var radians = this.worldRotation * spine.degRad;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        if (this.worldFlipX) {\n            this.m00 = -cos * this.worldScaleX;\n            this.m01 = sin * this.worldScaleY;\n        } else {\n            this.m00 = cos * this.worldScaleX;\n            this.m01 = -sin * this.worldScaleY;\n        }\n        if (this.worldFlipY != spine.Bone.yDown) {\n            this.m10 = -sin * this.worldScaleX;\n            this.m11 = -cos * this.worldScaleY;\n        } else {\n            this.m10 = sin * this.worldScaleX;\n            this.m11 = cos * this.worldScaleY;\n        }\n    },\n    setToSetupPose: function setToSetupPose() {\n        var data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.rotationIK = this.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.flipX = data.flipX;\n        this.flipY = data.flipY;\n    },\n    worldToLocal: function worldToLocal(world) {\n        var dx = world[0] - this.worldX,\n            dy = world[1] - this.worldY;\n        var m00 = this.m00,\n            m10 = this.m10,\n            m01 = this.m01,\n            m11 = this.m11;\n        if (this.worldFlipX != (this.worldFlipY != spine.Bone.yDown)) {\n            m00 = -m00;\n            m11 = -m11;\n        }\n        var invDet = 1 / (m00 * m11 - m01 * m10);\n        world[0] = dx * m00 * invDet - dy * m01 * invDet;\n        world[1] = dy * m11 * invDet - dx * m10 * invDet;\n    },\n    localToWorld: function localToWorld(local) {\n        var localX = local[0],\n            localY = local[1];\n        local[0] = localX * this.m00 + localY * this.m01 + this.worldX;\n        local[1] = localX * this.m10 + localY * this.m11 + this.worldY;\n    }\n};\nmodule.exports = spine.Bone;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/Bone.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/Bone.js?");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Animation = __webpack_require__(11);\nspine.Curves = __webpack_require__(27);\nspine.ColorTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, r, g, b, a, ...\n    this.frames.length = frameCount * 5;\n};\nspine.ColorTimeline.prototype = {\n    slotIndex: 0,\n    getFrameCount: function getFrameCount() {\n        return this.frames.length / 5;\n    },\n    setFrame: function setFrame(frameIndex, time, r, g, b, a) {\n        frameIndex *= 5;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = r;\n        this.frames[frameIndex + 2] = g;\n        this.frames[frameIndex + 3] = b;\n        this.frames[frameIndex + 4] = a;\n    },\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var r, g, b, a;\n        if (time >= frames[frames.length - 5]) {\n            // Time is after last frame.\n            var i = frames.length - 1;\n            r = frames[i - 3];\n            g = frames[i - 2];\n            b = frames[i - 1];\n            a = frames[i];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\n            var prevFrameR = frames[frameIndex - 4];\n            var prevFrameG = frames[frameIndex - 3];\n            var prevFrameB = frames[frameIndex - 2];\n            var prevFrameA = frames[frameIndex - 1];\n            var frameTime = frames[frameIndex];\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5 /*PREV_FRAME_TIME*/] - frameTime);\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\n\n            r = prevFrameR + (frames[frameIndex + 1 /*FRAME_R*/] - prevFrameR) * percent;\n            g = prevFrameG + (frames[frameIndex + 2 /*FRAME_G*/] - prevFrameG) * percent;\n            b = prevFrameB + (frames[frameIndex + 3 /*FRAME_B*/] - prevFrameB) * percent;\n            a = prevFrameA + (frames[frameIndex + 4 /*FRAME_A*/] - prevFrameA) * percent;\n        }\n        var slot = skeleton.slots[this.slotIndex];\n        if (alpha < 1) {\n            slot.r += (r - slot.r) * alpha;\n            slot.g += (g - slot.g) * alpha;\n            slot.b += (b - slot.b) * alpha;\n            slot.a += (a - slot.a) * alpha;\n        } else {\n            slot.r = r;\n            slot.g = g;\n            slot.b = b;\n            slot.a = a;\n        }\n    }\n};\nmodule.exports = spine.ColorTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/ColorTimeline.js\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/ColorTimeline.js?");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Animation = __webpack_require__(11);\nspine.DrawOrderTimeline = function (frameCount) {\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.drawOrders = [];\n    this.drawOrders.length = frameCount;\n};\nspine.DrawOrderTimeline.prototype = {\n    getFrameCount: function getFrameCount() {\n        return this.frames.length;\n    },\n    setFrame: function setFrame(frameIndex, time, drawOrder) {\n        this.frames[frameIndex] = time;\n        this.drawOrders[frameIndex] = drawOrder;\n    },\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameIndex;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frameIndex = frames.length - 1;else frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\n\n        var drawOrder = skeleton.drawOrder;\n        var slots = skeleton.slots;\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\n        if (drawOrderToSetupIndex) {\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++) {\n                drawOrder[i] = drawOrderToSetupIndex[i];\n            }\n        }\n    }\n};\nmodule.exports = spine.DrawOrderTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/DrawOrderTimeline.js\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/DrawOrderTimeline.js?");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.EventData = function (name) {\n    this.name = name;\n};\nspine.EventData.prototype = {\n    intValue: 0,\n    floatValue: 0,\n    stringValue: null\n};\nmodule.exports = spine.EventData;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/EventData.js\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/EventData.js?");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Event = function (data) {\n    this.data = data;\n};\nspine.Event.prototype = {\n    intValue: 0,\n    floatValue: 0,\n    stringValue: null\n};\nmodule.exports = spine.Event;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/Event.js\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/Event.js?");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Animation = __webpack_require__(11);\nspine.EventTimeline = function (frameCount) {\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.events = [];\n    this.events.length = frameCount;\n};\nspine.EventTimeline.prototype = {\n    getFrameCount: function getFrameCount() {\n        return this.frames.length;\n    },\n    setFrame: function setFrame(frameIndex, time, event) {\n        this.frames[frameIndex] = time;\n        this.events[frameIndex] = event;\n    },\n    /** Fires events for frames > lastTime and <= time. */\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        if (!firedEvents) return;\n\n        var frames = this.frames;\n        var frameCount = frames.length;\n\n        if (lastTime > time) {\n            // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameIndex;\n        if (lastTime < frames[0]) frameIndex = 0;else {\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\n            var frame = frames[frameIndex];\n            while (frameIndex > 0) {\n                // Fire multiple events with the same frame.\n                if (frames[frameIndex - 1] != frame) break;\n                frameIndex--;\n            }\n        }\n        var events = this.events;\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++) {\n            firedEvents.push(events[frameIndex]);\n        }\n    }\n};\nmodule.exports = spine.EventTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/EventTimeline.js\n ** module id = 34\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/EventTimeline.js?");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Animation = __webpack_require__(11);\nspine.Curves = __webpack_require__(27);\nspine.FfdTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = [];\n    this.frames.length = frameCount;\n    this.frameVertices = [];\n    this.frameVertices.length = frameCount;\n};\nspine.FfdTimeline.prototype = {\n    slotIndex: 0,\n    attachment: 0,\n    getFrameCount: function getFrameCount() {\n        return this.frames.length;\n    },\n    setFrame: function setFrame(frameIndex, time, vertices) {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n    },\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        var slot = skeleton.slots[this.slotIndex];\n        if (slot.attachment != this.attachment) return;\n\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameVertices = this.frameVertices;\n        var vertexCount = frameVertices[0].length;\n\n        var vertices = slot.attachmentVertices;\n        if (vertices.length != vertexCount) {\n            vertices = slot.attachmentVertices = [];\n            for (var k = 0; k < vertexCount; k++) {\n                vertices.push(0);\n            } // Don't mix from uninitialized slot vertices.\n            alpha = 1;\n        }\n\n        if (time >= frames[frames.length - 1]) {\n            // Time is after last frame.\n            var lastVertices = frameVertices[frames.length - 1];\n            if (alpha < 1) {\n                for (var i = 0; i < vertexCount; i++) {\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n                }\n            } else {\n                for (var i = 0; i < vertexCount; i++) {\n                    vertices[i] = lastVertices[i];\n                }\n            }\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : percent > 1 ? 1 : percent);\n\n        var prevVertices = frameVertices[frameIndex - 1];\n        var nextVertices = frameVertices[frameIndex];\n\n        if (alpha < 1) {\n            for (var i = 0; i < vertexCount; i++) {\n                var prev = prevVertices[i];\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n            }\n        } else {\n            for (var i = 0; i < vertexCount; i++) {\n                var prev = prevVertices[i];\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\n            }\n        }\n    }\n};\nmodule.exports = spine.FfdTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/FfdTimeline.js\n ** module id = 35\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/FfdTimeline.js?");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Animation = __webpack_require__(11);\nspine.Curves = __webpack_require__(27);\nspine.FlipXTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, flip, ...\n    this.frames.length = frameCount * 2;\n};\nspine.FlipXTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function getFrameCount() {\n        return this.frames.length / 2;\n    },\n    setFrame: function setFrame(frameIndex, time, flip) {\n        frameIndex *= 2;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = flip ? 1 : 0;\n    },\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) {\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\n            return;\n        } else if (lastTime > time) //\n            lastTime = -1;\n        var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;\n        if (frames[frameIndex] < lastTime) return;\n        skeleton.bones[this.boneIndex].flipX = frames[frameIndex + 1] != 0;\n    }\n};\nmodule.exports = spine.FlipXTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/FlipXTimeline.js\n ** module id = 36\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/FlipXTimeline.js?");

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Animation = __webpack_require__(11);\nspine.Curves = __webpack_require__(27);\nspine.FlipYTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, flip, ...\n    this.frames.length = frameCount * 2;\n};\nspine.FlipYTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function getFrameCount() {\n        return this.frames.length / 2;\n    },\n    setFrame: function setFrame(frameIndex, time, flip) {\n        frameIndex *= 2;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = flip ? 1 : 0;\n    },\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) {\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\n            return;\n        } else if (lastTime > time) //\n            lastTime = -1;\n        var frameIndex = (time >= frames[frames.length - 2] ? frames.length : spine.Animation.binarySearch(frames, time, 2)) - 2;\n        if (frames[frameIndex] < lastTime) return;\n        skeleton.bones[this.boneIndex].flipY = frames[frameIndex + 1] != 0;\n    }\n};\nmodule.exports = spine.FlipYTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/FlipYTimeline.js\n ** module id = 37\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/FlipYTimeline.js?");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10) || {};\nspine.IkConstraintData = function (name) {\n    this.name = name;\n    this.bones = [];\n};\nspine.IkConstraintData.prototype = {\n    target: null,\n    bendDirection: 1,\n    mix: 1\n};\nmodule.exports = spine.IkConstraintData;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/IkConstraintData.js\n ** module id = 38\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/IkConstraintData.js?");

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.IkConstraint = function (data, skeleton) {\n    this.data = data;\n    this.mix = data.mix;\n    this.bendDirection = data.bendDirection;\n\n    this.bones = [];\n    for (var i = 0, n = data.bones.length; i < n; i++) {\n        this.bones.push(skeleton.findBone(data.bones[i].name));\n    }this.target = skeleton.findBone(data.target.name);\n};\nspine.IkConstraint.prototype = {\n    apply: function apply() {\n        var target = this.target;\n        var bones = this.bones;\n        switch (bones.length) {\n            case 1:\n                spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\n                break;\n            case 2:\n                spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n                break;\n        }\n    }\n};\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n * coordinate system. */\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha) {\n    var parentRotation = !bone.data.inheritRotation || !bone.parent ? 0 : bone.parent.worldRotation;\n    var rotation = bone.rotation;\n    // worldY and targetY sign depends on global constant spine.Bone.yDown\n    var rotationIK = (spine.Bone.yDown ? -spine.radDeg : spine.radDeg) * Math.atan2(targetY - bone.worldY, targetX - bone.worldX) - parentRotation;\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\n};\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n * target is specified in the world coordinate system.\n * @param child Any descendant bone of the parent. */\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDirection, alpha) {\n    var childRotation = child.rotation,\n        parentRotation = parent.rotation;\n    if (!alpha) {\n        child.rotationIK = childRotation;\n        parent.rotationIK = parentRotation;\n        return;\n    }\n    var positionX,\n        positionY,\n        tempPosition = spine.temp;\n    var parentParent = parent.parent;\n    if (parentParent) {\n        tempPosition[0] = targetX;\n        tempPosition[1] = targetY;\n        parentParent.worldToLocal(tempPosition);\n        targetX = (tempPosition[0] - parent.x) * parentParent.worldScaleX;\n        targetY = (tempPosition[1] - parent.y) * parentParent.worldScaleY;\n    } else {\n        targetX -= parent.x;\n        targetY -= parent.y;\n    }\n    if (child.parent == parent) {\n        positionX = child.x;\n        positionY = child.y;\n    } else {\n        tempPosition[0] = child.x;\n        tempPosition[1] = child.y;\n        child.parent.localToWorld(tempPosition);\n        parent.worldToLocal(tempPosition);\n        positionX = tempPosition[0];\n        positionY = tempPosition[1];\n    }\n    var childX = positionX * parent.worldScaleX,\n        childY = positionY * parent.worldScaleY;\n    var offset = Math.atan2(childY, childX);\n    var len1 = Math.sqrt(childX * childX + childY * childY),\n        len2 = child.data.length * child.worldScaleX;\n    // Based on code by Ryan Juckett with permission: Copyright (c) 2008-2009 Ryan Juckett, http://www.ryanjuckett.com/\n    var cosDenom = 2 * len1 * len2;\n    if (cosDenom < 0.0001) {\n        child.rotationIK = childRotation + (Math.atan2(targetY, targetX) * spine.radDeg - parentRotation - childRotation) * alpha;\n        return;\n    }\n    var cos = (targetX * targetX + targetY * targetY - len1 * len1 - len2 * len2) / cosDenom;\n    if (cos < -1) cos = -1;else if (cos > 1) cos = 1;\n    var childAngle = Math.acos(cos) * bendDirection;\n    var adjacent = len1 + len2 * cos,\n        opposite = len2 * Math.sin(childAngle);\n    var parentAngle = Math.atan2(targetY * adjacent - targetX * opposite, targetX * adjacent + targetY * opposite);\n    var rotation = (parentAngle - offset) * spine.radDeg - parentRotation;\n    if (rotation > 180) rotation -= 360;else if (rotation < -180) //\n        rotation += 360;\n    parent.rotationIK = parentRotation + rotation * alpha;\n    rotation = (childAngle + offset) * spine.radDeg - childRotation;\n    if (rotation > 180) rotation -= 360;else if (rotation < -180) //\n        rotation += 360;\n    child.rotationIK = childRotation + (rotation + parent.worldRotation - child.parent.worldRotation) * alpha;\n};\nmodule.exports = spine.IkConstraint;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/IkConstraint.js\n ** module id = 39\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/IkConstraint.js?");

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10) || {};\nspine.Animation = __webpack_require__(11);\nspine.Curves = __webpack_require__(27);\nspine.IkConstraintTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, mix, bendDirection, ...\n    this.frames.length = frameCount * 3;\n};\nspine.IkConstraintTimeline.prototype = {\n    ikConstraintIndex: 0,\n    getFrameCount: function getFrameCount() {\n        return this.frames.length / 3;\n    },\n    setFrame: function setFrame(frameIndex, time, mix, bendDirection) {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = mix;\n        this.frames[frameIndex + 2] = bendDirection;\n    },\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (time >= frames[frames.length - 3]) {\n            // Time is after last frame.\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\n            ikConstraint.bendDirection = frames[frames.length - 1];\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameMix = frames[frameIndex + -2 /*PREV_FRAME_MIX*/];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3 /*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        var mix = prevFrameMix + (frames[frameIndex + 1 /*FRAME_MIX*/] - prevFrameMix) * percent;\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\n        ikConstraint.bendDirection = frames[frameIndex + -1 /*PREV_FRAME_BEND_DIRECTION*/];\n    }\n};\nmodule.exports = spine.IkConstraintTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/IkConstraintTimeline.js\n ** module id = 40\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/IkConstraintTimeline.js?");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10) || {};\nspine.Animation = __webpack_require__(11);\nspine.Curves = __webpack_require__(27);\nspine.RotateTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, angle, ...\n    this.frames.length = frameCount * 2;\n};\nspine.RotateTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function getFrameCount() {\n        return this.frames.length / 2;\n    },\n    setFrame: function setFrame(frameIndex, time, angle) {\n        frameIndex *= 2;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = angle;\n    },\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 2]) {\n            // Time is after last frame.\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\n            while (amount > 180) {\n                amount -= 360;\n            }while (amount < -180) {\n                amount += 360;\n            }bone.rotation += amount * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\n        var prevFrameValue = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2 /*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\n\n        var amount = frames[frameIndex + 1 /*FRAME_VALUE*/] - prevFrameValue;\n        while (amount > 180) {\n            amount -= 360;\n        }while (amount < -180) {\n            amount += 360;\n        }amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\n        while (amount > 180) {\n            amount -= 360;\n        }while (amount < -180) {\n            amount += 360;\n        }bone.rotation += amount * alpha;\n    }\n};\nmodule.exports = spine.RotateTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/RotateTimeline.js\n ** module id = 41\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/RotateTimeline.js?");

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Animation = __webpack_require__(11);\nspine.Curves = __webpack_require__(27);\nspine.ScaleTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.ScaleTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function getFrameCount() {\n        return this.frames.length / 3;\n    },\n    setFrame: function setFrame(frameIndex, time, x, y) {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3]) {\n            // Time is after last frame.\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameX = frames[frameIndex - 2];\n        var prevFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3 /*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1 /*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2 /*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\n    }\n};\nmodule.exports = spine.ScaleTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/ScaleTimeline.js\n ** module id = 42\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/ScaleTimeline.js?");

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(9) || {};\nspine.AttachmentType = __webpack_require__(17);\nspine.SkeletonBounds = function () {\n    this.polygonPool = [];\n    this.polygons = [];\n    this.boundingBoxes = [];\n};\nspine.SkeletonBounds.prototype = {\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\n    update: function update(skeleton, updateAabb) {\n        var slots = skeleton.slots;\n        var slotCount = slots.length;\n        var x = skeleton.x,\n            y = skeleton.y;\n        var boundingBoxes = this.boundingBoxes;\n        var polygonPool = this.polygonPool;\n        var polygons = this.polygons;\n\n        boundingBoxes.length = 0;\n        for (var i = 0, n = polygons.length; i < n; i++) {\n            polygonPool.push(polygons[i]);\n        }polygons.length = 0;\n\n        for (var i = 0; i < slotCount; i++) {\n            var slot = slots[i];\n            var boundingBox = slot.attachment;\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\n            boundingBoxes.push(boundingBox);\n\n            var poolCount = polygonPool.length,\n                polygon;\n            if (poolCount > 0) {\n                polygon = polygonPool[poolCount - 1];\n                polygonPool.splice(poolCount - 1, 1);\n            } else polygon = [];\n            polygons.push(polygon);\n\n            polygon.length = boundingBox.vertices.length;\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\n        }\n\n        if (updateAabb) this.aabbCompute();\n    },\n    aabbCompute: function aabbCompute() {\n        var polygons = this.polygons;\n        var minX = Number.MAX_VALUE,\n            minY = Number.MAX_VALUE,\n            maxX = Number.MIN_VALUE,\n            maxY = Number.MIN_VALUE;\n        for (var i = 0, n = polygons.length; i < n; i++) {\n            var vertices = polygons[i];\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                var x = vertices[ii];\n                var y = vertices[ii + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    },\n    /** Returns true if the axis aligned bounding box contains the point. */\n    aabbContainsPoint: function aabbContainsPoint(x, y) {\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n    },\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\n    aabbIntersectsSegment: function aabbIntersectsSegment(x1, y1, x2, y2) {\n        var minX = this.minX,\n            minY = this.minY,\n            maxX = this.maxX,\n            maxY = this.maxY;\n        if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) return false;\n        var m = (y2 - y1) / (x2 - x1);\n        var y = m * (minX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        var x = (minY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        return false;\n    },\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n    aabbIntersectsSkeleton: function aabbIntersectsSkeleton(bounds) {\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n    },\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n    containsPoint: function containsPoint(x, y) {\n        var polygons = this.polygons;\n        for (var i = 0, n = polygons.length; i < n; i++) {\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\n        }return null;\n    },\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\r\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\n    intersectsSegment: function intersectsSegment(x1, y1, x2, y2) {\n        var polygons = this.polygons;\n        for (var i = 0, n = polygons.length; i < n; i++) {\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\n        }return null;\n    },\n    /** Returns true if the polygon contains the point. */\n    polygonContainsPoint: function polygonContainsPoint(polygon, x, y) {\n        var nn = polygon.length;\n        var prevIndex = nn - 2;\n        var inside = false;\n        for (var ii = 0; ii < nn; ii += 2) {\n            var vertexY = polygon[ii + 1];\n            var prevY = polygon[prevIndex + 1];\n            if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {\n                var vertexX = polygon[ii];\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\n            }\n            prevIndex = ii;\n        }\n        return inside;\n    },\n    /** Returns true if the polygon contains the line segment. */\n    polygonIntersectsSegment: function polygonIntersectsSegment(polygon, x1, y1, x2, y2) {\n        var nn = polygon.length;\n        var width12 = x1 - x2,\n            height12 = y1 - y2;\n        var det1 = x1 * y2 - y1 * x2;\n        var x3 = polygon[nn - 2],\n            y3 = polygon[nn - 1];\n        for (var ii = 0; ii < nn; ii += 2) {\n            var x4 = polygon[ii],\n                y4 = polygon[ii + 1];\n            var det2 = x3 * y4 - y3 * x4;\n            var width34 = x3 - x4,\n                height34 = y3 - y4;\n            var det3 = width12 * height34 - height12 * width34;\n            var x = (det1 * width34 - width12 * det2) / det3;\n            if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {\n                var y = (det1 * height34 - height12 * det2) / det3;\n                if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true;\n            }\n            x3 = x4;\n            y3 = y4;\n        }\n        return false;\n    },\n    getPolygon: function getPolygon(attachment) {\n        var index = this.boundingBoxes.indexOf(attachment);\n        return index == -1 ? null : this.polygons[index];\n    },\n    getWidth: function getWidth() {\n        return this.maxX - this.minX;\n    },\n    getHeight: function getHeight() {\n        return this.maxY - this.minY;\n    }\n};\nmodule.exports = spine.SkeletonBounds;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/SkeletonBounds.js\n ** module id = 43\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/SkeletonBounds.js?");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.SkeletonData = function () {\n    this.bones = [];\n    this.slots = [];\n    this.skins = [];\n    this.events = [];\n    this.animations = [];\n    this.ikConstraints = [];\n};\nspine.SkeletonData.prototype = {\n    name: null,\n    defaultSkin: null,\n    width: 0, height: 0,\n    version: null, hash: null,\n    /** @return May be null. */\n    findBone: function findBone(boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++) {\n            if (bones[i].name == boneName) return bones[i];\n        }return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function findBoneIndex(boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++) {\n            if (bones[i].name == boneName) return i;\n        }return -1;\n    },\n    /** @return May be null. */\n    findSlot: function findSlot(slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++) {\n            if (slots[i].name == slotName) return this.slots[i];\n        }\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function findSlotIndex(slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++) {\n            if (slots[i].name == slotName) return i;\n        }return -1;\n    },\n    /** @return May be null. */\n    findSkin: function findSkin(skinName) {\n        var skins = this.skins;\n        for (var i = 0, n = skins.length; i < n; i++) {\n            if (skins[i].name == skinName) return skins[i];\n        }return null;\n    },\n    /** @return May be null. */\n    findEvent: function findEvent(eventName) {\n        var events = this.events;\n        for (var i = 0, n = events.length; i < n; i++) {\n            if (events[i].name == eventName) return events[i];\n        }return null;\n    },\n    /** @return May be null. */\n    findAnimation: function findAnimation(animationName) {\n        var animations = this.animations;\n        for (var i = 0, n = animations.length; i < n; i++) {\n            if (animations[i].name == animationName) return animations[i];\n        }return null;\n    },\n    /** @return May be null. */\n    findIkConstraint: function findIkConstraint(ikConstraintName) {\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++) {\n            if (ikConstraints[i].name == ikConstraintName) return ikConstraints[i];\n        }return null;\n    }\n};\nmodule.exports = spine.SkeletonData;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/SkeletonData.js\n ** module id = 44\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/SkeletonData.js?");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Bone = __webpack_require__(29);\nspine.Slot = __webpack_require__(46);\nspine.IkConstraint = __webpack_require__(39);\nspine.Skeleton = function (skeletonData) {\n    this.data = skeletonData;\n\n    this.bones = [];\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++) {\n        var boneData = skeletonData.bones[i];\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\n        this.bones.push(new spine.Bone(boneData, this, parent));\n    }\n\n    this.slots = [];\n    this.drawOrder = [];\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++) {\n        var slotData = skeletonData.slots[i];\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\n        var slot = new spine.Slot(slotData, bone);\n        this.slots.push(slot);\n        this.drawOrder.push(i);\n    }\n\n    this.ikConstraints = [];\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++) {\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\n    }this.boneCache = [];\n    this.updateCache();\n};\nspine.Skeleton.prototype = {\n    x: 0, y: 0,\n    skin: null,\n    r: 1, g: 1, b: 1, a: 1,\n    time: 0,\n    flipX: false, flipY: false,\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\n    updateCache: function updateCache() {\n        var ikConstraints = this.ikConstraints;\n        var ikConstraintsCount = ikConstraints.length;\n\n        var arrayCount = ikConstraintsCount + 1;\n        var boneCache = this.boneCache;\n        if (boneCache.length > arrayCount) boneCache.length = arrayCount;\n        for (var i = 0, n = boneCache.length; i < n; i++) {\n            boneCache[i].length = 0;\n        }while (boneCache.length < arrayCount) {\n            boneCache[boneCache.length] = [];\n        }var nonIkBones = boneCache[0];\n        var bones = this.bones;\n\n        outer: for (var i = 0, n = bones.length; i < n; i++) {\n            var bone = bones[i];\n            var current = bone;\n            do {\n                for (var ii = 0; ii < ikConstraintsCount; ii++) {\n                    var ikConstraint = ikConstraints[ii];\n                    var parent = ikConstraint.bones[0];\n                    var child = ikConstraint.bones[ikConstraint.bones.length - 1];\n                    while (true) {\n                        if (current == child) {\n                            boneCache[ii].push(bone);\n                            boneCache[ii + 1].push(bone);\n                            continue outer;\n                        }\n                        if (child == parent) break;\n                        child = child.parent;\n                    }\n                }\n                current = current.parent;\n            } while (current);\n            nonIkBones[nonIkBones.length] = bone;\n        }\n    },\n    /** Updates the world transform for each bone. */\n    updateWorldTransform: function updateWorldTransform() {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++) {\n            var bone = bones[i];\n            bone.rotationIK = bone.rotation;\n        }\n        var i = 0,\n            last = this.boneCache.length - 1;\n        while (true) {\n            var cacheBones = this.boneCache[i];\n            for (var ii = 0, nn = cacheBones.length; ii < nn; ii++) {\n                cacheBones[ii].updateWorldTransform();\n            }if (i == last) break;\n            this.ikConstraints[i].apply();\n            i++;\n        }\n    },\n    /** Sets the bones and slots to their setup pose values. */\n    setToSetupPose: function setToSetupPose() {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    },\n    setBonesToSetupPose: function setBonesToSetupPose() {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++) {\n            bones[i].setToSetupPose();\n        }var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++) {\n            var ikConstraint = ikConstraints[i];\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\n            ikConstraint.mix = ikConstraint.data.mix;\n        }\n    },\n    setSlotsToSetupPose: function setSlotsToSetupPose() {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++) {\n            slots[i].setToSetupPose(i);\n        }\n\n        this.resetDrawOrder();\n    },\n    /** @return May return null. */\n    getRootBone: function getRootBone() {\n        return this.bones.length ? this.bones[0] : null;\n    },\n    /** @return May be null. */\n    findBone: function findBone(boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++) {\n            if (bones[i].data.name == boneName) return bones[i];\n        }return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function findBoneIndex(boneName) {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++) {\n            if (bones[i].data.name == boneName) return i;\n        }return -1;\n    },\n    /** @return May be null. */\n    findSlot: function findSlot(slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++) {\n            if (slots[i].data.name == slotName) return slots[i];\n        }return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function findSlotIndex(slotName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++) {\n            if (slots[i].data.name == slotName) return i;\n        }return -1;\n    },\n    setSkinByName: function setSkinByName(skinName) {\n        var skin = this.data.findSkin(skinName);\n        if (!skin) throw \"Skin not found: \" + skinName;\n        this.setSkin(skin);\n    },\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\r\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\r\n     * @param newSkin May be null. */\n    setSkin: function setSkin(newSkin) {\n        if (newSkin) {\n            if (this.skin) newSkin._attachAll(this, this.skin);else {\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    var slot = slots[i];\n                    var name = slot.data.attachmentName;\n                    if (name) {\n                        var attachment = newSkin.getAttachment(i, name);\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    },\n    /** @return May be null. */\n    getAttachmentBySlotName: function getAttachmentBySlotName(slotName, attachmentName) {\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\n    },\n    /** @return May be null. */\n    getAttachmentBySlotIndex: function getAttachmentBySlotIndex(slotIndex, attachmentName) {\n        if (this.skin) {\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    },\n    /** @param attachmentName May be null. */\n    setAttachment: function setAttachment(slotName, attachmentName) {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++) {\n            var slot = slots[i];\n            if (slot.data.name == slotName) {\n                var attachment = null;\n                if (attachmentName) {\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw \"Slot not found: \" + slotName;\n    },\n    /** @return May be null. */\n    findIkConstraint: function findIkConstraint(ikConstraintName) {\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++) {\n            if (ikConstraints[i].data.name == ikConstraintName) return ikConstraints[i];\n        }return null;\n    },\n    update: function update(delta) {\n        this.time += delta;\n    },\n    resetDrawOrder: function resetDrawOrder() {\n        for (var i = 0, n = this.drawOrder.length; i < n; i++) {\n            this.drawOrder[i] = i;\n        }\n    }\n};\nmodule.exports = spine.Skeleton;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/Skeleton.js\n ** module id = 45\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/Skeleton.js?");

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Slot = function (slotData, bone) {\n    this.data = slotData;\n    this.bone = bone;\n    this.setToSetupPose();\n};\nspine.Slot.prototype = {\n    r: 1, g: 1, b: 1, a: 1,\n    _attachmentTime: 0,\n    attachment: null,\n    attachmentVertices: [],\n    setAttachment: function setAttachment(attachment) {\n        this.attachment = attachment;\n        this._attachmentTime = this.bone.skeleton.time;\n        this.attachmentVertices.length = 0;\n    },\n    setAttachmentTime: function setAttachmentTime(time) {\n        this._attachmentTime = this.bone.skeleton.time - time;\n    },\n    getAttachmentTime: function getAttachmentTime() {\n        return this.bone.skeleton.time - this._attachmentTime;\n    },\n    setToSetupPose: function setToSetupPose() {\n        var data = this.data;\n        this.r = data.r;\n        this.g = data.g;\n        this.b = data.b;\n        this.a = data.a;\n        this.blendMode = data.blendMode;\n\n        var slotDatas = this.bone.skeleton.data.slots;\n        for (var i = 0, n = slotDatas.length; i < n; i++) {\n            if (slotDatas[i] == data) {\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\n                break;\n            }\n        }\n    }\n};\nmodule.exports = spine.Slot;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/Slot.js\n ** module id = 46\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/Slot.js?");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.SkeletonData = __webpack_require__(44);\nspine.BoneData = __webpack_require__(28);\nspine.IkConstraintData = __webpack_require__(38);\nspine.SlotData = __webpack_require__(48);\nspine.Skin = __webpack_require__(49);\nspine.EventData = __webpack_require__(32);\nspine.AttachmentType = __webpack_require__(17);\nspine.ColorTimeline = __webpack_require__(30);\nspine.AttachmentTimeline = __webpack_require__(26);\nspine.RotateTimeline = __webpack_require__(41);\nspine.ScaleTimeline = __webpack_require__(42);\nspine.TranslateTimeline = __webpack_require__(50);\nspine.FlipXTimeline = __webpack_require__(36);\nspine.FlipYTimeline = __webpack_require__(37);\nspine.IkConstraintTimeline = __webpack_require__(40);\nspine.FfdTimeline = __webpack_require__(35);\nspine.DrawOrderTimeline = __webpack_require__(31);\nspine.EventTimeline = __webpack_require__(34);\nspine.Event = __webpack_require__(33);\nspine.Animation = __webpack_require__(11);\nspine.SkeletonJsonParser = function (attachmentLoader) {\n    this.attachmentLoader = attachmentLoader;\n};\nspine.SkeletonJsonParser.prototype = {\n    scale: 1,\n    readSkeletonData: function readSkeletonData(root, name) {\n        var skeletonData = new spine.SkeletonData();\n        skeletonData.name = name;\n\n        // Skeleton.\n        var skeletonMap = root[\"skeleton\"];\n        if (skeletonMap) {\n            skeletonData.hash = skeletonMap[\"hash\"];\n            skeletonData.version = skeletonMap[\"spine\"];\n            skeletonData.width = skeletonMap[\"width\"] || 0;\n            skeletonData.height = skeletonMap[\"height\"] || 0;\n        }\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++) {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"]) {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = boneMap[\"rotation\"] || 0;\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\n            skeletonData.bones.push(boneData);\n        }\n\n        // IK constraints.\n        var ik = root[\"ik\"];\n        if (ik) {\n            for (var i = 0, n = ik.length; i < n; i++) {\n                var ikMap = ik[i];\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\n\n                var bones = ikMap[\"bones\"];\n                for (var ii = 0, nn = bones.length; ii < nn; ii++) {\n                    var bone = skeletonData.findBone(bones[ii]);\n                    if (!bone) throw \"IK bone not found: \" + bones[ii];\n                    ikConstraintData.bones.push(bone);\n                }\n\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\n                if (!ikConstraintData.target) throw \"Target bone not found: \" + ikMap[\"target\"];\n\n                ikConstraintData.bendDirection = !ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"] ? 1 : -1;\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\n\n                skeletonData.ikConstraints.push(ikConstraintData);\n            }\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (var i = 0, n = slots.length; i < n; i++) {\n            var slotMap = slots[i];\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color) {\n                slotData.r = this.toColor(color, 0);\n                slotData.g = this.toColor(color, 1);\n                slotData.b = this.toColor(color, 2);\n                slotData.a = this.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins) {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap) {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry) {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        // Events.\n        var events = root[\"events\"];\n        for (var eventName in events) {\n            if (!events.hasOwnProperty(eventName)) continue;\n            var eventMap = events[eventName];\n            var eventData = new spine.EventData(eventName);\n            eventData.intValue = eventMap[\"int\"] || 0;\n            eventData.floatValue = eventMap[\"float\"] || 0;\n            eventData.stringValue = eventMap[\"string\"] || null;\n            skeletonData.events.push(eventData);\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations) {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function readAttachment(skin, name, map) {\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n        var path = map[\"path\"] || name;\n\n        var scale = this.scale;\n        if (type == spine.AttachmentType.region) {\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n            if (!region) return null;\n            region.path = path;\n            region.x = (map[\"x\"] || 0) * scale;\n            region.y = (map[\"y\"] || 0) * scale;\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\n            region.rotation = map[\"rotation\"] || 0;\n            region.width = (map[\"width\"] || 0) * scale;\n            region.height = (map[\"height\"] || 0) * scale;\n\n            var color = map[\"color\"];\n            if (color) {\n                region.r = this.toColor(color, 0);\n                region.g = this.toColor(color, 1);\n                region.b = this.toColor(color, 2);\n                region.a = this.toColor(color, 3);\n            }\n\n            region.updateOffset();\n            return region;\n        } else if (type == spine.AttachmentType.mesh) {\n            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\n            mesh.triangles = this.getIntArray(map, \"triangles\");\n            mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\n            mesh.updateUVs();\n\n            color = map[\"color\"];\n            if (color) {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n\n            mesh.hullLength = (map[\"hull\"] || 0) * 2;\n            if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n            return mesh;\n        } else if (type == spine.AttachmentType.skinnedmesh) {\n            var mesh = this.attachmentLoader.newSkinnedMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n\n            var uvs = this.getFloatArray(map, \"uvs\", 1);\n            var vertices = this.getFloatArray(map, \"vertices\", 1);\n            var weights = [];\n            var bones = [];\n            for (var i = 0, n = vertices.length; i < n;) {\n                var boneCount = vertices[i++] | 0;\n                bones[bones.length] = boneCount;\n                for (var nn = i + boneCount * 4; i < nn;) {\n                    bones[bones.length] = vertices[i];\n                    weights[weights.length] = vertices[i + 1] * scale;\n                    weights[weights.length] = vertices[i + 2] * scale;\n                    weights[weights.length] = vertices[i + 3];\n                    i += 4;\n                }\n            }\n            mesh.bones = bones;\n            mesh.weights = weights;\n            mesh.triangles = this.getIntArray(map, \"triangles\");\n            mesh.regionUVs = uvs;\n            mesh.updateUVs();\n\n            color = map[\"color\"];\n            if (color) {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n\n            mesh.hullLength = (map[\"hull\"] || 0) * 2;\n            if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n            return mesh;\n        } else if (type == spine.AttachmentType.boundingbox) {\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n            var vertices = map[\"vertices\"];\n            for (var i = 0, n = vertices.length; i < n; i++) {\n                attachment.vertices.push(vertices[i] * scale);\n            }return attachment;\n        }\n        throw \"Unknown attachment type: \" + type;\n    },\n    readAnimation: function readAnimation(name, map, skeletonData) {\n        var timelines = [];\n        var duration = 0;\n\n        var slots = map[\"slots\"];\n        for (var slotName in slots) {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (var timelineName in slotMap) {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                var values = slotMap[timelineName];\n                if (timelineName == \"color\") {\n                    var timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++) {\n                        var valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = this.toColor(color, 0);\n                        var g = this.toColor(color, 1);\n                        var b = this.toColor(color, 2);\n                        var a = this.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n                } else if (timelineName == \"attachment\") {\n                    var timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++) {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                } else throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones) {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (var timelineName in boneMap) {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                var values = boneMap[timelineName];\n                if (timelineName == \"rotate\") {\n                    var timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++) {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n                } else if (timelineName == \"translate\" || timelineName == \"scale\") {\n                    var timeline;\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\") timeline = new spine.ScaleTimeline(values.length);else {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++) {\n                        var valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\") {\n                    var x = timelineName == \"flipX\";\n                    var timeline = x ? new spine.FlipXTimeline(values.length) : new spine.FlipYTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var field = x ? \"x\" : \"y\";\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++) {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[field] || false);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n                } else throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n\n        var ikMap = map[\"ik\"];\n        for (var ikConstraintName in ikMap) {\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\n            var values = ikMap[ikConstraintName];\n            var timeline = new spine.IkConstraintTimeline(values.length);\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++) {\n                var valueMap = values[i];\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\n                var bendDirection = !valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"] ? 1 : -1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n        }\n\n        var ffd = map[\"ffd\"];\n        for (var skinName in ffd) {\n            var skin = skeletonData.findSkin(skinName);\n            var slotMap = ffd[skinName];\n            for (slotName in slotMap) {\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var meshMap = slotMap[slotName];\n                for (var meshName in meshMap) {\n                    var values = meshMap[meshName];\n                    var timeline = new spine.FfdTimeline(values.length);\n                    var attachment = skin.getAttachment(slotIndex, meshName);\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\n                    timeline.slotIndex = slotIndex;\n                    timeline.attachment = attachment;\n\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\n                    var vertexCount;\n                    if (isMesh) vertexCount = attachment.vertices.length;else vertexCount = attachment.weights.length / 3 * 2;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++) {\n                        var valueMap = values[i];\n                        var vertices;\n                        if (!valueMap[\"vertices\"]) {\n                            if (isMesh) vertices = attachment.vertices;else {\n                                vertices = [];\n                                for (var j = 0; j < vertexCount; ++j) {\n                                    vertices.push(0);\n                                } //initialize to 0\n                            }\n                        } else {\n                                var verticesValue = valueMap[\"vertices\"];\n                                vertices = [];\n                                for (var j = 0; j < vertexCount; ++j) {\n                                    vertices.push(0);\n                                } //initialize to 0\n                                var start = valueMap[\"offset\"] || 0;\n                                var nn = verticesValue.length;\n                                if (this.scale == 1) {\n                                    for (var ii = 0; ii < nn; ii++) {\n                                        vertices[ii + start] = verticesValue[ii];\n                                    }\n                                } else {\n                                    for (var ii = 0; ii < nn; ii++) {\n                                        vertices[ii + start] = verticesValue[ii] * this.scale;\n                                    }\n                                }\n                                if (isMesh) {\n                                    var meshVertices = attachment.vertices;\n                                    for (var ii = 0, nn = vertices.length; ii < nn; ii++) {\n                                        vertices[ii] += meshVertices[ii];\n                                    }\n                                }\n                            }\n\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines[timelines.length] = timeline;\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n            }\n        }\n\n        var drawOrderValues = map[\"drawOrder\"];\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\n        if (drawOrderValues) {\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\n            var slotCount = skeletonData.slots.length;\n            var frameIndex = 0;\n            for (var i = 0, n = drawOrderValues.length; i < n; i++) {\n                var drawOrderMap = drawOrderValues[i];\n                var drawOrder = null;\n                if (drawOrderMap[\"offsets\"]) {\n                    drawOrder = [];\n                    drawOrder.length = slotCount;\n                    for (var ii = slotCount - 1; ii >= 0; ii--) {\n                        drawOrder[ii] = -1;\n                    }var offsets = drawOrderMap[\"offsets\"];\n                    var unchanged = [];\n                    unchanged.length = slotCount - offsets.length;\n                    var originalIndex = 0,\n                        unchangedIndex = 0;\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++) {\n                        var offsetMap = offsets[ii];\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex) {\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        } // Set changed items.\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount) {\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    } // Fill in unchanged items.\n                    for (var ii = slotCount - 1; ii >= 0; ii--) {\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                    }\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        var events = map[\"events\"];\n        if (events) {\n            var timeline = new spine.EventTimeline(events.length);\n            var frameIndex = 0;\n            for (var i = 0, n = events.length; i < n; i++) {\n                var eventMap = events[i];\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\n                var event = new spine.Event(eventData);\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    },\n    readCurve: function readCurve(timeline, frameIndex, valueMap) {\n        var curve = valueMap[\"curve\"];\n        if (!curve) timeline.curves.setLinear(frameIndex);else if (curve == \"stepped\") timeline.curves.setStepped(frameIndex);else if (curve instanceof Array) timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n    },\n    toColor: function toColor(hexString, colorIndex) {\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n        return parseInt(hexString.substring(colorIndex * 2, colorIndex * 2 + 2), 16) / 255;\n    },\n    getFloatArray: function getFloatArray(map, name, scale) {\n        var list = map[name];\n        var values = new spine.Float32Array(list.length);\n        var i = 0,\n            n = list.length;\n        if (scale == 1) {\n            for (; i < n; i++) {\n                values[i] = list[i];\n            }\n        } else {\n            for (; i < n; i++) {\n                values[i] = list[i] * scale;\n            }\n        }\n        return values;\n    },\n    getIntArray: function getIntArray(map, name) {\n        var list = map[name];\n        var values = new spine.Uint16Array(list.length);\n        for (var i = 0, n = list.length; i < n; i++) {\n            values[i] = list[i] | 0;\n        }return values;\n    }\n};\nmodule.exports = spine.SkeletonJsonParser;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/SkeletonJsonParser.js\n ** module id = 47\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/SkeletonJsonParser.js?");

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.SlotData = function (name, boneData) {\n    this.name = name;\n    this.boneData = boneData;\n};\n\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\n    'screen': PIXI.BLEND_MODES.SCREEN,\n    'additive': PIXI.BLEND_MODES.ADD,\n    'normal': PIXI.BLEND_MODES.NORMAL\n};\n\nspine.SlotData.prototype = {\n    r: 1, g: 1, b: 1, a: 1,\n    attachmentName: null,\n    blendMode: PIXI.BLEND_MODES.NORMAL\n\n};\n\nmodule.exports = spine.SlotData;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/SlotData.js\n ** module id = 48\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/SlotData.js?");

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar spine = __webpack_require__(10);\nspine.Skin = function (name) {\n    this.name = name;\n    this.attachments = {};\n};\nspine.Skin.prototype = {\n    addAttachment: function addAttachment(slotIndex, name, attachment) {\n        this.attachments[slotIndex + \":\" + name] = attachment;\n    },\n    getAttachment: function getAttachment(slotIndex, name) {\n        return this.attachments[slotIndex + \":\" + name];\n    },\n    _attachAll: function _attachAll(skeleton, oldSkin) {\n        for (var key in oldSkin.attachments) {\n            var colon = key.indexOf(\":\");\n            var slotIndex = parseInt(key.substring(0, colon));\n            var name = key.substring(colon + 1);\n            var slot = skeleton.slots[slotIndex];\n            if (slot.attachment && slot.attachment.name == name) {\n                var attachment = this.getAttachment(slotIndex, name);\n                if (attachment) slot.setAttachment(attachment);\n            }\n        }\n    }\n};\nmodule.exports = spine.Skin;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/Skin.js\n ** module id = 49\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/Skin.js?");

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(10);\nspine.Animation = __webpack_require__(11);\nspine.Curves = __webpack_require__(27);\nspine.TranslateTimeline = function (frameCount) {\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.TranslateTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function getFrameCount() {\n        return this.frames.length / 3;\n    },\n    setFrame: function setFrame(frameIndex, time, x, y) {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function apply(skeleton, lastTime, time, firedEvents, alpha) {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3]) {\n            // Time is after last frame.\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameX = frames[frameIndex - 2];\n        var prevFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3 /*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1 /*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2 /*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\n    }\n};\nmodule.exports = spine.TranslateTimeline;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/SpineRuntime/TranslateTimeline.js\n ** module id = 50\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/SpineRuntime/TranslateTimeline.js?");

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar Resource = PIXI.loaders.Resource,\n    spine = __webpack_require__(9),\n    imageLoaderAdapter = __webpack_require__(52);\n\nvar atlasParser = module.exports = function () {\n    return function (resource, next) {\n        // skip if no data, its not json, or it isn't atlas data\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\n            return next();\n        }\n\n        /**\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\n         * have the same name\n         */\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + '.atlas';\n        var atlasOptions = {\n            crossOrigin: resource.crossOrigin,\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT,\n            metadata: resource.metadata.spineMetadata\n        };\n        var imageOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata.imageMetadata\n        };\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\n            new spine.Atlas(this.xhr.responseText, adapter, function (spineAtlas) {\n                var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n                resource.spineData = skeletonData;\n                resource.spineAtlas = spineAtlas;\n                if (atlasParser.enableCaching) atlasParser.AnimCache[resource.name] = resource.spineData;\n\n                next();\n            });\n        });\n    };\n};\n\natlasParser.AnimCache = {};\natlasParser.enableCaching = true;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/loaders/atlasParser.js\n ** module id = 51\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/loaders/atlasParser.js?");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar spine = __webpack_require__(9);\n\nmodule.exports = function (loader, namePrefix, baseUrl, imageOptions) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {\n        baseUrl += '/';\n    }\n    return function (line, callback) {\n        var name = namePrefix + line;\n        var url = baseUrl + line;\n        loader.add(name, url, imageOptions, function (resource) {\n            callback(resource.texture.baseTexture);\n        });\n    };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/loaders/imageLoaderAdapter.js\n ** module id = 52\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/loaders/imageLoaderAdapter.js?");

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = {\n    atlasParser: __webpack_require__(51),\n    Loader: __webpack_require__(54),\n    syncImageLoaderAdapter: __webpack_require__(25),\n    imageLoaderAdapter: __webpack_require__(52)\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/loaders/index.js\n ** module id = 53\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/loaders/index.js?");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\r\n * @file        Spine resource loader\r\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\r\n * @copyright   2013-2015 GoodBoyDigital\r\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\r\n */\n\n/**\r\n * @namespace PIXI.loaders\r\n */\n\nvar atlasParser = __webpack_require__(51);\n\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\nPIXI.loader.use(atlasParser());\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pixi-spine/src/loaders/Loader.js\n ** module id = 54\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/pixi-spine/src/loaders/Loader.js?");

/***/ },
/* 55 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/**\n * Created by wizard on 15/3/3.\n */\n\nvar Inherited = function Inherited(obj) {\n    var registry = {};\n\n    obj.inheritOn = function (name, handler) {\n\n        if (!obj.hasOwnProperty(name)) {\n            obj[name] = handler;\n            return;\n        }\n\n        if (registry.hasOwnProperty(name)) {\n            registry[name].push(handler);\n        } else {\n            var parentHandler = obj[name];\n            registry[name] = [parentHandler, handler];\n\n            obj[name] = function () {\n                var result = void 0;\n                var handlerList = registry[name];\n                for (var index in handlerList) {\n                    result = handlerList[index].apply(this, arguments);\n                    if (result != undefined && !result) {\n                        return result;\n                    }\n                }\n\n                return result;\n            };\n        }\n    };\n\n    return obj;\n};\nmodule.exports = Inherited;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/tools/inherited.js\n ** module id = 55\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/tools/inherited.js?");

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\n * Created by guolei on 16/3/15.\n */\n\nvar Conf = __webpack_require__(2);\n\nvar DemoLayer = {\n    id: 'main',\n    component: 'Window',\n    padding: 4,\n    position: { x: 0, y: 0 },\n    width: Conf.Canvas.width,\n    height: Conf.Canvas.height,\n    layout: [1, 4],\n    children: [{\n        component: 'Layout',\n        position: { x: 0, y: 0 },\n        width: 200,\n        height: 50,\n        layout: [2, 1],\n        children: [{\n            id: 'gold',\n            component: 'Button',\n            image: {\n                \"default\": \"./assets/img/text_diamond_select.png\",\n                \"down\": \"./assets/img/text_diamond_normal.png\"\n            },\n            position: 'center',\n            width: 157,\n            height: 46\n        }, {\n            id: 'gold_num',\n            text: '1111111',\n            font: {\n                size: '26px',\n                family: 'Skranji',\n                color: 'yellow'\n            },\n            component: 'Label',\n            position: { x: -10, y: 0 },\n            width: 100,\n            height: 50\n        }]\n    }, null, {\n        component: 'Layout',\n        position: { x: 50, y: 150 },\n        width: 400,\n        height: 100,\n        layout: [4, 1],\n        children: [{\n            id: 'attack',\n            text: 'attack:',\n            font: {\n                size: '26px',\n                family: 'Skranji',\n                color: 'white'\n            },\n            component: 'Label',\n            //image:{ \"default\": \"./assets/img/bomb1.png\", \"down\": \"./assets/img/bomb1-selected.png\" },\n            position: 'center',\n            width: 110,\n            height: 50\n        }, {\n            id: 'attack_num',\n            text: '111',\n            font: {\n                size: '26px',\n                family: 'Skranji',\n                color: 'blue'\n            },\n            component: 'Label',\n            position: 'center',\n            width: 110,\n            height: 50\n        }, {\n            id: 'life',\n            text: 'life:',\n            font: {\n                size: '26px',\n                family: 'Skranji',\n                color: 'red'\n            },\n            component: 'Label',\n            position: 'center',\n            width: 110,\n            height: 50\n        }, {\n            id: 'life_num',\n            text: '200',\n            font: {\n                size: '26px',\n                family: 'Skranji',\n                color: 'gray'\n            },\n            component: 'Label',\n            position: 'center',\n            width: 110,\n            height: 50\n        }, null, null]\n    }, {\n        component: 'Layout',\n        position: { x: 0, y: 0 },\n        width: Conf.Canvas.width - 8,\n        height: 150,\n        layout: [4, 1],\n        children: [{\n            id: 'feed',\n            text: 'feed',\n            font: {\n                size: '26px',\n                family: 'Skranji',\n                color: 'white'\n            },\n            component: 'Button',\n            //image:{ \"default\": \"./assets/img/bomb1.png\", \"down\": \"./assets/img/bomb1-selected.png\" },\n            position: 'center',\n            width: 110,\n            height: 50\n        }, {\n            id: 'bathe',\n            text: 'bathe',\n            font: {\n                size: '26px',\n                family: 'Skranji',\n                color: 'blue'\n            },\n            component: 'Button',\n            position: 'center',\n            width: 110,\n            height: 50\n        }, {\n            id: 'shopping',\n            text: 'shop',\n            font: {\n                size: '26px',\n                family: 'Skranji',\n                color: 'green'\n            },\n            component: 'Button',\n            position: 'center',\n            width: 110,\n            height: 50\n        }, {\n            id: 'exercise',\n            text: 'exercise',\n            font: {\n                size: '26px',\n                family: 'Skranji',\n                color: 'gray'\n            },\n            component: 'Button',\n            position: 'center',\n            width: 110,\n            height: 50\n        }]\n    }]\n};\nmodule.exports = DemoLayer;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/gui-layouts/demo-layout.js\n ** module id = 56\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/gui-layouts/demo-layout.js?");

/***/ },
/* 57 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/**\n * Created by guolei on 16/3/21.\n */\nvar res = {\n    \"catSpine\": \"./assets/animations/skeleton.json\",\n    \"game_bg\": \"./assets/img/background_fight_snow.png\",\n    \"diamond_normal\": \"./assets/img/text_diamond_normal.png\",\n    \"diamond_select\": \"./assets/img/text_diamond_select.png\"\n};\nvar g_resources = [];\nfor (var i in res) {\n    g_resources.push(res[i]);\n}\n\nmodule.exports = { res: res, g_res: g_resources };\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/resource.js\n ** module id = 57\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/resource.js?");

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\n * Created by guolei on 16/3/22.\n */\nvar configManager = __webpack_require__(3);\nvar Tool = __webpack_require__(59);\nvar PetData = function () {\n    var that = {};\n    var _petSumExp = 900;\n    var _petData = {\n        level: 0,\n        currentLevelExp: 0,\n        levelExp: 0,\n        life: 100,\n        attack: 5\n    };\n    var _petLevelData = null;\n\n    that.init = function () {\n        _petLevelData = configManager.getConfigByType(Tool.conf.ConfigType.PetLevels);\n        var level = 0;\n        var sumExp = 0;\n        for (var i in _petLevelData) {\n            var levelExp = _petLevelData[i].experience;\n            sumExp += levelExp;\n\n            if (_petSumExp <= sumExp) {\n                _petData.life = _petLevelData[i].life;\n                _petData.attack = _petLevelData[i].attack;\n                _petData.currentLevelExp = sumExp - _petSumExp;\n                _petData.levelExp = _petLevelData[i].experience;\n                _petData.level = level;\n                return;\n            }\n            level++;\n        }\n    };\n\n    that.addExp = function (exp) {\n        _petSumExp += exp;\n        console.log('levelExp', _petData.levelExp, 'level', _petData.level, 'currentLevelExp', _petData.currentLevelExp);\n        _petData.currentLevelExp += exp;\n        if (_petData.currentLevelExp >= _petData.levelExp) {\n            _petData.level += 1;\n            var levelData = _petLevelData['level_' + _petData.level];\n            _petData.currentLevelExp = _petData.currentLevelExp - _petData.levelExp;\n            _petData.levelExp = levelData.experience;\n            _petData.life = levelData.life;\n            _petData.attack = levelData.attack;\n            Tool.event.fire('levelUp');\n        }\n    };\n\n    that.getPetData = function () {\n        return _petData;\n    };\n\n    return that;\n}();\nmodule.exports = PetData;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/data/pet-data.js\n ** module id = 58\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/data/pet-data.js?");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\n * Created by guolei on 16/3/21.\n */\nvar Utils = __webpack_require__(6);\nvar Conf = __webpack_require__(2);\nvar Eventuality = __webpack_require__(60);\n\nvar Tools = Tools || {};\nTools.utils = Utils;\nTools.conf = Conf;\nTools.event = Eventuality({});\n\nmodule.exports = Tools;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/tools/tools.js\n ** module id = 59\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/tools/tools.js?");

/***/ },
/* 60 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nvar Eventuality = function Eventuality(obj) {\n    var registry = {};\n\n    obj.fire = function (event) {\n\n        var handler = null;\n\n        if (registry.hasOwnProperty(event)) {\n            var event_list = registry[event];\n            for (var i = 0; i < event_list.length; ++i) {\n                handler = event_list[i];\n                var args = [];\n\n                //not including event\n                for (var n = 1; n < arguments.length; ++n) {\n                    args.push(arguments[n]);\n                }\n                handler.apply(this, args);\n            }\n        }\n\n        return this;\n    };\n\n    obj.on = function (type, method) {\n        if (registry.hasOwnProperty(type)) {\n            registry[type].push(method);\n        } else {\n            registry[type] = [method];\n        }\n\n        return this;\n    };\n\n    obj.removeListener = function (type, method) {\n        if (!registry.hasOwnProperty(type)) {\n            return false;\n        }\n        var index = registry[type].indexOf(method);\n        if (index >= 0) {\n            registry[type].splice(index, 1);\n        }\n    };\n\n    obj.removeAllListeners = function () {\n        registry = {};\n    };\n    return obj;\n};\nmodule.exports = Eventuality;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/tools/eventuality.js\n ** module id = 60\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/tools/eventuality.js?");

/***/ },
/* 61 */
/***/ function(module, exports) {

	eval("'use strict';\n\n/**\n * Created by guolei on 16/3/22.\n */\nvar TimerButton = function TimerButton(button, time) {\n    var that = {};\n    var _cdTime = time;\n    var _fixedTime = 1.0;\n    var _goCD = false;\n    var _showText = button.text;\n    button.buttonMode = true;\n    that.click = function (callFunc) {\n        button.on('click', function (event, me) {\n            if (_goCD) return;\n            _goCD = true;\n            button.interactive = false;\n            button.text = _cdTime;\n            callFunc(event, me);\n        });\n    };\n\n    that.update = function (dt) {\n        if (!_goCD) return;\n\n        _fixedTime -= dt;\n        if (_fixedTime <= 0) {\n            if (_cdTime > 0) {\n                _cdTime -= 1.0;\n                button.text = _cdTime;\n            } else {\n                button.text = _showText;\n                _goCD = false;\n                button.interactive = true;\n                _cdTime = time;\n            }\n            _fixedTime += 1.0;\n        }\n    };\n\n    return that;\n};\nmodule.exports = TimerButton;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/buttons/timer-button.js\n ** module id = 61\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/buttons/timer-button.js?");

/***/ },
/* 62 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nfunction scaleToWindow(canvas, backgroundColor) {\n\n    backgroundColor = backgroundColor || \"#2C3539\";\n    var scaleX, scaleY, scale, center;\n\n    //1. Scale the canvas to the correct size\n    //Figure out the scale amount on each axis\n    scaleX = window.innerWidth / canvas.offsetWidth;\n    scaleY = window.innerHeight / canvas.offsetHeight;\n\n    //Scale the canvas based on whichever value is less: `scaleX` or `scaleY`\n    scale = Math.min(scaleX, scaleY);\n    canvas.style.transformOrigin = \"0 0\";\n    canvas.style.transform = \"scale(\" + scale + \")\";\n    console.log(scaleX);\n\n    //2. Center the canvas.\n    //Decide whether to center the canvas vertically or horizontally.\n    //Wide canvases should be centered vertically, and\n    //square or tall canvases should be centered horizontally\n    if (canvas.offsetwidth > canvas.offsetHeight) {\n        if (canvas.offsetWidth * scale < window.innerWidth) {\n            center = \"horizontally\";\n        } else {\n            center = \"vertically\";\n        }\n    } else {\n        if (canvas.offsetHeight * scale < window.innerHeight) {\n            center = \"vertically\";\n        } else {\n            center = \"horizontally\";\n        }\n    }\n\n    //Center horizontally (for square or tall canvases)\n    var margin;\n    if (center === \"horizontally\") {\n        margin = (window.innerWidth - canvas.offsetWidth * scale) / 2;\n        canvas.style.marginLeft = margin + \"px\";\n        canvas.style.marginRight = margin + \"px\";\n    }\n\n    //Center vertically (for wide canvases)\n    if (center === \"vertically\") {\n        margin = (window.innerHeight - canvas.offsetHeight * scale) / 2;\n        canvas.style.marginTop = margin + \"px\";\n        canvas.style.marginBottom = margin + \"px\";\n    }\n\n    //3. Remove any padding from the canvas  and body and set the canvas\n    //display style to \"block\"\n    canvas.style.paddingLeft = 0;\n    canvas.style.paddingRight = 0;\n    canvas.style.paddingTop = 0;\n    canvas.style.paddingBottom = 0;\n    canvas.style.display = \"block\";\n\n    //4. Set the color of the HTML body background\n    document.body.style.backgroundColor = backgroundColor;\n\n    //Fix some quirkiness in scaling for Safari\n    var ua = navigator.userAgent.toLowerCase();\n    if (ua.indexOf(\"safari\") != -1) {\n        if (ua.indexOf(\"chrome\") > -1) {\n            // Chrome\n        } else {\n                // Safari\n                //canvas.style.maxHeight = \"100%\";\n                //canvas.style.minHeight = \"100%\";\n            }\n    }\n\n    //5. Return the `scale` value. This is important, because you'll nee this value\n    //for correct hit testing between the pointer and sprites\n    return scale;\n}\nmodule.exports = scaleToWindow;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./public/games/FightPower/src/tools/scaleToWindow.js\n ** module id = 62\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./public/games/FightPower/src/tools/scaleToWindow.js?");

/***/ }
/******/ ]);